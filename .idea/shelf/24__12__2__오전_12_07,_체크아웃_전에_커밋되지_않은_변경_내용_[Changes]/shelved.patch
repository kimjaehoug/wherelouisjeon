Index: src/main/java/kr/jbnu/se/std/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package kr.jbnu.se.std;\r\n\r\nimport java.awt.*;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.net.URL;\r\nimport java.util.*;\r\nimport java.util.List;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport javax.imageio.ImageIO;\r\nimport javax.sound.sampled.*;\r\nimport java.util.Random;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * Actual game.\r\n *\r\n * @author www.gametutorial.net\r\n */\r\n\r\npublic class Game {\r\n\r\n    /**\r\n     * We use this to generate a random number.\r\n     */\r\n    private Random random = new Random();\r\n    List<GiftBox> giftBoxes = new ArrayList<>();\r\n    long lastGiftBoxTime = 0;\r\n    int minInterval = 9000; // 최소 간격 3초\r\n    int maxInterval = 30000; // 최대 간격 10초\r\n    int giftBoxInterval = getRandomInterval(minInterval, maxInterval); // 랜덤 간격\r\n    private Clip clip;\r\n    private Clip clipbg;\r\n    public int ed = 0;\r\n    private boolean isPause = false;\r\n    private int Round;\r\n    private boolean isBossAlive;\r\n    private Duck[] hunterSelectedDucks;\r\n    private Duck[] FireSelectedDucks;\r\n    private Duck[] playerSelectedDucks;\r\n    private int ammo;// 현재 사용 가능한 총알\r\n    boolean ending = true;\r\n    private int maxAmmo;       // 한 번에 장전할 수 있는 최대 탄약 수\r\n    private BufferedImage gameoverfImg;\r\n    private boolean isReloading; // 장전 중인지 여부\r\n    private long reloadStartTime; // 장전이 시작된 시간\r\n    private long reloadDuration;  // 장전 시간 (예: 2초)\r\n    private URL hpUrl;\r\n    private long endingStartTime = -1; // 엔딩이 시작된 시간을 저장하는 변수\r\n    private int selectduck;\r\n    private ScheduledExecutorService hunterExecutor;\r\n    private ScheduledExecutorService FireExecutor;\r\n    private int PlayerHp;\r\n    private BufferedImage sightImg_Fire;\r\n    private BufferedImage[] giftBoxImages = new BufferedImage[3];\r\n\r\n    /**\r\n     * Font that we will use to write statistic to the screen.\r\n     */\r\n    private Font font;\r\n    private BufferedImage gameoverImg;\r\n    boolean hunterTrigger = true;\r\n    private int damage;\r\n    private long lastClickTime = 0; // 마지막으로 클릭한 시간\r\n    private final long clickDelay = 1000; // 클릭 사이의 최소 간격 (밀리초)\r\n    private BufferedImage bossImg;\r\n    private BufferedImage boss2Img;\r\n    private BufferedImage boss3Img;\r\n    private BufferedImage boss4Img;\r\n    private BufferedImage boss5Img;\r\n    private BufferedImage bossAttack;\r\n    private BufferedImage hunter111Img;\r\n    private BufferedImage bossAttack2;\r\n    private BufferedImage bossAttack3;\r\n    private BufferedImage bossAttack4;\r\n    private BufferedImage bossAttack5;\r\n    private BufferedImage warningImg;\r\n    private BufferedImage[] hpImages = new BufferedImage[12];\r\n    private BufferedImage[] shopImages = new BufferedImage[4];// HP 이미지를 저장할 배열\r\n    private BufferedImage[] endingImages = new BufferedImage[4];\r\n    private int duckspeed;\r\n\r\n    /**\r\n     * Array list of the ducks.\r\n     */\r\n    private ArrayList<Duck> ducks;\r\n    private ArrayList<boss1> boss;\r\n    private ArrayList<Buttonbuy> buttonbuy;\r\n    private long lastBossAttackTime = 0;  // 마지막 공격 시간\r\n    private final long bossAttackInterval = 3000;\r\n    long lastBottomAttackTime = 0;\r\n    long bottomAttackInterval = 4000; // 공격 간격 (3초)\r\n    private ArrayList<Hunter1> Hunters;\r\n    private boolean Bosswith3delay;\r\n\r\n    /**\r\n     * How many ducks leave the screen alive?\r\n     */\r\n    private int runawayDucks;\r\n    private Framework framework;\r\n\r\n    /**\r\n     * How many ducks the player killed?\r\n     */\r\n    private int killedDucks;\r\n\r\n    /**\r\n     * For each killed duck, the player gets points.\r\n     */\r\n    private int score;\r\n    private int money;\r\n\r\n    /**\r\n     * How many times a player is shot?\r\n     */\r\n    private int shoots;\r\n    private boolean leaderboardSaved;\r\n    /**\r\n     * Last time of the shoot.\r\n     */\r\n    private long lastTimeShoot;\r\n    private boolean fire = false;\r\n    /**\r\n     * The time which must elapse between shots.\r\n     */\r\n    private long timeBetweenShots;\r\n    private BufferedImage giftBoxImg1;\r\n    private BufferedImage giftBoxImg2;\r\n    private BufferedImage giftBoxImg3;\r\n    /**\r\n     * kr.jbnu.se.std.Game background image.\r\n     */\r\n    private BufferedImage backgroundImg;\r\n    private BufferedImage backgroundImg2;\r\n    private BufferedImage backgroundImg3;\r\n    private BufferedImage backgroundImg4;\r\n    private BufferedImage backgroundImg5;\r\n    private BufferedImage buttonImg;\r\n    private BufferedImage sightImg_hunter;\r\n\r\n    /**\r\n     * Bottom grass.\r\n     */\r\n    private BufferedImage grassImg;\r\n\r\n    /**\r\n     * kr.jbnu.se.std.Duck image.\r\n     */\r\n    private BufferedImage duckImg;\r\n\r\n    /**\r\n     * Shotgun sight image.\r\n     */\r\n    private BufferedImage sightImg;\r\n    private boolean Hunter1 = false;\r\n\r\n    /**\r\n     * Middle width of the sight image.\r\n     */\r\n    private int sightImgMiddleWidth;\r\n    /**\r\n     * Middle height of the sight image.\r\n     */\r\n    private int sightImgMiddleHeight;\r\n    private String gun;\r\n    private List<BossAttack> bossAttacks = new ArrayList<>();\r\n    private List<BossAttack> bossAttacks2 = new ArrayList<>();\r\n    private List<BossAttack> bossAttacks3 = new ArrayList<>();\r\n    private List<BossAttack> bossAttacks4 = new ArrayList<>();\r\n    private List<BossAttack> bossAttacks5 = new ArrayList<>();\r\n    private int roundPass;\r\n\r\n    private static final String HIT_SOUND_PATH = \"src/main/resources/sounds/hit.wav\";\r\n    private static final String HIT_MESSAGE = \"Player hit! Remaining health: \";\r\n    private static final String BOSSATTCK_SOUND_PATH = \"src/main/resources/sounds/bossattck.wav\";\r\n\r\n    private static final String BUY_BUTTON_MESSAGE = \"buybutton\";\r\n    private static final String MOUSE_POSITION_MESSAGE = \"Mouse Position: \";\r\n    private static final String BUTTON_POSITION_MESSAGE = \"Button Position: \";\r\n\r\n\r\n\r\n    public Game(Framework framework) {\r\n        Framework.gameState = Framework.GameState.GAME_CONTENT_LOADING;\r\n        this.framework = framework;\r\n        Thread threadForInitGame = new Thread() {\r\n            @Override\r\n            public void run() {\r\n                // Sets variables and objects for the game.\r\n                Initialize();\r\n                // Load game files (images, sounds, ...)\r\n                LoadContent();\r\n\r\n                playBackgroundMusic(\"src/main/resources/sounds/MoonlightShadow.wav\");\r\n\r\n                updateGameState(Framework.GameState.PLAYING);\r\n            }\r\n        };\r\n        threadForInitGame.start();\r\n    }\r\n\r\n    // 게임 상태를 안전하게 업데이트하는 동기화된 메서드\r\n    private synchronized void updateGameState(Framework.GameState newState) {\r\n        Framework.gameState = newState;\r\n    }\r\n\r\n    // 랜덤한 시간 간격 생성 메서드\r\n    public int getRandomInterval(int min, int max) {\r\n        return min + (int) (Math.random() * (max - min));\r\n    }\r\n\r\n    /**\r\n     * Set variables and objects for the game.\r\n     */\r\n    private void Initialize() {\r\n        random = new Random();\r\n        font = new Font(\"monospaced\", Font.BOLD, 18);\r\n\r\n        ducks = new ArrayList<Duck>();\r\n        boss = new ArrayList<boss1>();\r\n        buttonbuy = new ArrayList<Buttonbuy>();\r\n        Hunters = new ArrayList<Hunter1>();\r\n        money = 0;\r\n        runawayDucks = 0;\r\n        killedDucks = 0;\r\n        score = 0;\r\n        roundPass = 60;\r\n        shoots = 0;\r\n        PlayerHp = 100;\r\n        Round = 1;\r\n        damage = 20;\r\n        isBossAlive = false;\r\n        Hunter1 = false;\r\n        lastTimeShoot = 0;\r\n        timeBetweenShots = 500_000_000L;\r\n\r\n        ammo = 6;              // 기본 탄약 수\r\n        maxAmmo = 6;           // 최대 장전할 수 있는 탄약 수\r\n        isReloading = false;   // 초기에는 장전 중이 아님\r\n        reloadDuration = 2000000000L; // 장전 시간 2초 (나노초 단위)\r\n    }\r\n\r\n    /**\r\n     * Load game files - images, sounds, ...\r\n     */\r\n    private void LoadContent() {\r\n        try {\r\n            loadImages(\"/images/hp_\", 12, hpImages);\r\n            loadImages(\"/images/shop\", 3, shopImages);\r\n            loadImages(\"/images/ending_\", 3, endingImages);\r\n\r\n            hunter111Img = loadImage(\"/images/hunterrrrr.png\");\r\n            gameoverImg = loadImage(\"/images/diegame.png\");\r\n            buttonImg = loadImage(\"/images/btn_buy.png\");\r\n\r\n            boss2Img = loadImage(\"/images/boss_crocs.png\");\r\n            boss3Img = loadImage(\"/images/boss_hippo.png\");\r\n            boss4Img = loadImage(\"/images/boss_dugong.png\");\r\n            boss5Img = loadImage(\"/images/duck_boss1.png\");\r\n\r\n            backgroundImg = loadImage(\"/images/background.png\");\r\n            backgroundImg3 = loadImage(\"/images/background_SAFARI.png\");\r\n            backgroundImg4 = loadImage(\"/images/bossbackground4.png\");\r\n            backgroundImg5 = loadImage(\"/images/boss_lv5.png\");\r\n            backgroundImg2 = loadImage(\"/images/background_mud.png\");\r\n\r\n            warningImg = loadImage(\"/images/warning.png\");\r\n            bossImg = loadImage(\"/images/boss.png\");\r\n            grassImg = loadImage(\"/images/grass.png\");\r\n            sightImg_hunter = loadImage(\"/images/sight_hunter.png\");\r\n            duckImg = loadImage(\"/images/duck.png\");\r\n            gameoverfImg = loadImage(\"/images/duck.png\");\r\n            sightImg = loadImage(\"/images/sight.png\");\r\n\r\n            sightImgMiddleWidth = sightImg.getWidth() / 2;\r\n            sightImgMiddleHeight = sightImg.getHeight() / 2;\r\n\r\n            bossAttack2 = loadImage(\"/images/crocs_mud.png\");\r\n            bossAttack3 = loadImage(\"/images/crocs_mud.png\");\r\n            bossAttack4 = loadImage(\"/images/waterball.png\");\r\n            bossAttack5 = loadImage(\"/images/skull.png\");\r\n            bossAttack = loadImage(\"/images/attack1.png\");\r\n\r\n            // giftBoxImages 배열에 이미지 로드\r\n            for (int i = 0; i < giftBoxImages.length; i++) {\r\n                giftBoxImages[i] = loadImage(\"/images/giftbox.png\");\r\n            }\r\n\r\n            sightImg_Fire = loadImage(\"/images/fire.png\");\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(Game.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n    }\r\n\r\n    // 이미지 로드를 위한 공통 메서드\r\n    private BufferedImage loadImage(String path) throws IOException {\r\n        URL imgUrl = this.getClass().getResource(path);\r\n        if (imgUrl != null) {\r\n            return ImageIO.read(imgUrl);\r\n        } else {\r\n            System.out.println(\"Image not found: \" + path);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // 여러 이미지를 로드할 수 있는 메서드\r\n    private void loadImages(String basePath, int count, BufferedImage[] imageArray) {\r\n        for (int i = 0; i < count; i++) {\r\n            String path = basePath + i + \".png\";\r\n            try {\r\n                imageArray[i] = loadImage(path);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void selectPlayerDucks(int numberOfDucks) {\r\n        // 선택된 오리들이 이미 있으면 리턴\r\n        if (playerSelectedDucks != null) {\r\n            return;\r\n        }\r\n\r\n        // 오리들이 충분히 있을 때 N마리 오리를 무작위로 선택\r\n        if (ducks.size() >= numberOfDucks) {\r\n            playerSelectedDucks = new Duck[numberOfDucks]; // Player 선택된 오리 배열 초기화\r\n\r\n            Set<Duck> selectedDucksSet = new HashSet<>();\r\n            selectedDucksSet.addAll(Arrays.asList(hunterSelectedDucks));\r\n\r\n            for (int i = 0; i < numberOfDucks; i++) {\r\n                Duck selectedDuck;\r\n                int index;\r\n\r\n                // 중복되지 않는 오리를 선택\r\n                do {\r\n                    index = random.nextInt(ducks.size());\r\n                    selectedDuck = ducks.get(index);\r\n                } while (selectedDucksSet.contains(selectedDuck));\r\n\r\n                playerSelectedDucks[i] = selectedDuck;\r\n                selectedDucksSet.add(selectedDuck);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // N마리 오리를 선택하는 메소드 (Hunter용)\r\n    private void selectHunterDucks(int numberOfDucks) {\r\n        if (ducks.size() >= numberOfDucks) {\r\n            hunterSelectedDucks = new Duck[numberOfDucks]; // Hunter 선택된 오리 배열 초기화\r\n            Set<Duck> selectedDucksSet = new HashSet<>();\r\n\r\n            for (int i = 0; i < numberOfDucks; i++) {\r\n                Duck selectedDuck;\r\n                int index;\r\n\r\n                // 중복되지 않는 오리를 선택\r\n                do {\r\n                    index = random.nextInt(ducks.size());\r\n                    selectedDuck = ducks.get(index);\r\n                } while (Arrays.asList(hunterSelectedDucks).contains(selectedDuck) || (playerSelectedDucks != null && Arrays.asList(playerSelectedDucks).contains(selectedDuck))); // 중복 방지\r\n\r\n                hunterSelectedDucks[i] = selectedDuck;\r\n                selectedDucksSet.add(selectedDuck);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // N마리 오리를 선택하는 메소드 (Hunter용)\r\n    private void selectFireDucks(int numberOfDucks) {\r\n        if (ducks.size() >= numberOfDucks) {\r\n            FireSelectedDucks = new Duck[numberOfDucks]; // Hunter 선택된 오리 배열 초기화\r\n            Set<Duck> selectedDucksSet = new HashSet<>();\r\n\r\n            for (int i = 0; i < numberOfDucks; i++) {\r\n                Duck selectedDuck;\r\n                int index;\r\n\r\n                // 중복되지 않는 오리를 선택\r\n                do {\r\n                    index = random.nextInt(ducks.size());\r\n                    selectedDuck = ducks.get(index);\r\n                } while (Arrays.asList(hunterSelectedDucks).contains(selectedDuck) ||\r\n                        (hunterSelectedDucks != null && Arrays.asList(hunterSelectedDucks).contains(selectedDuck)) ||\r\n                        (playerSelectedDucks != null && Arrays.asList(playerSelectedDucks).contains(selectedDuck))); // 중복 방지\r\n\r\n                FireSelectedDucks[i] = selectedDuck;\r\n                selectedDucksSet.add(selectedDuck);\r\n\r\n                System.out.println(\"Selected Fire Ducks: \" + Arrays.toString(FireSelectedDucks));\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    // Hunter가 자동으로 오리를 제거하는 메소드\r\n    private void startFireAutoKill(int interval) {\r\n        if (FireExecutor == null || FireExecutor.isShutdown()) {\r\n            FireExecutor = Executors.newScheduledThreadPool(1); // 새로 생성\r\n        }\r\n        FireExecutor.scheduleAtFixedRate(() -> {\r\n            if (FireSelectedDucks == null || Arrays.stream(FireSelectedDucks).allMatch(Objects::isNull)) {\r\n                // Hunter가 선택한 오리가 없으면 새롭게 선택\r\n                selectFireDucks(1);\r\n            }\r\n            if (FireSelectedDucks != null) {\r\n                for (Duck duck : FireSelectedDucks) {\r\n                    if (duck != null\r\n                            && !Arrays.asList(playerSelectedDucks).contains(duck)\r\n                            && !Arrays.asList(hunterSelectedDucks).contains(duck)) {\r\n                        // Hunter가 선택한 오리가 Player가 선택한 오리와 중복되지 않도록 확인\r\n                        ducks.remove(duck);\r\n                        killedDucks++;\r\n                        money += 10;\r\n                        score += duck.score;\r\n                        System.out.println(\"Hunter가 오리를 죽였습니다: \" + duck);\r\n                        break; // 한 마리씩 죽이고 나가도록\r\n\r\n                    }\r\n                }\r\n                updateFireSelectedDucks();\r\n            }\r\n        }, 0, interval, TimeUnit.MILLISECONDS); // interval 시간마다 실행\r\n    }\r\n\r\n\r\n\r\n    // 게임이 끝나면 Hunter의 자동조준 타이머를 중지하는 코드\r\n    private void stopFireAutoKill() {\r\n        if (FireExecutor != null && !FireExecutor.isShutdown()) {\r\n            FireExecutor.shutdown(); // Hunter의 자동 조준 종료\r\n        }\r\n    }\r\n\r\n\r\n    private void updateFireSelectedDucks() {\r\n        for (int i = 0; i < FireSelectedDucks.length; i++) {\r\n            if (hunterSelectedDucks[i] == null || !ducks.contains(hunterSelectedDucks[i]) || !ducks.contains(playerSelectedDucks[i])) {\r\n                // 새로운 오리를 선택하여 중복되지 않게 추가\r\n                Duck selectedDuck;\r\n                int index;\r\n\r\n                Set<Duck> selectedDucksSet = new HashSet<>();\r\n                selectedDucksSet.addAll(Arrays.asList(hunterSelectedDucks));\r\n                selectedDucksSet.addAll(Arrays.asList(playerSelectedDucks));\r\n                selectedDucksSet.addAll(Arrays.asList(FireSelectedDucks));\r\n\r\n                do {\r\n                    index = random.nextInt(ducks.size());\r\n                    selectedDuck = ducks.get(index);\r\n                } while (Arrays.asList(hunterSelectedDucks).contains(selectedDuck) ||\r\n                        Arrays.asList(playerSelectedDucks).contains(selectedDuck) ||\r\n                        Arrays.asList(FireSelectedDucks).contains(selectedDuck)); // 중복 방지\r\n\r\n                FireSelectedDucks[i] = selectedDuck;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // Hunter가 자동으로 오리를 제거하는 메소드\r\n    private void startHunterAutoKill(int interval) {\r\n        if (hunterExecutor == null || hunterExecutor.isShutdown()) {\r\n            hunterExecutor = Executors.newScheduledThreadPool(1); // 새로 생성\r\n        }\r\n        hunterExecutor.scheduleAtFixedRate(() -> {\r\n            if (hunterSelectedDucks == null || Arrays.stream(hunterSelectedDucks).allMatch(Objects::isNull)) {\r\n                // Hunter가 선택한 오리가 없으면 새롭게 선택\r\n                selectHunterDucks(1);\r\n            }\r\n            if (hunterSelectedDucks != null) {\r\n                for (Duck duck : hunterSelectedDucks) {\r\n                    if (duck != null && !Arrays.asList(playerSelectedDucks).contains(duck)) {\r\n                        // Hunter가 선택한 오리가 Player가 선택한 오리와 중복되지 않도록 확인\r\n                        ducks.remove(duck);\r\n                        killedDucks++;\r\n                        money += 10;\r\n                        score += duck.score;\r\n                        System.out.println(\"Hunter가 오리를 죽였습니다: \" + duck);\r\n                        break; // 한 마리씩 죽이고 나가도록\r\n\r\n                    }\r\n                }\r\n                updateHunterSelectedDucks();\r\n            }\r\n        }, 0, interval, TimeUnit.MILLISECONDS); // interval 시간마다 실행\r\n    }\r\n\r\n\r\n    // 게임이 끝나면 Hunter의 자동조준 타이머를 중지하는 코드\r\n    private void stopHunterAutoKill() {\r\n        if (hunterExecutor != null && !hunterExecutor.isShutdown()) {\r\n            hunterExecutor.shutdown(); // Hunter의 자동 조준 종료\r\n        }\r\n    }\r\n\r\n\r\n    private void updateAndReselectPlayerDucks(int numberOfDucks) {\r\n        // playerSelectedDucks가 null일 때만 새로 선택\r\n        playerSelectedDucks = null;\r\n        if (playerSelectedDucks == null) {\r\n            selectPlayerDucks(numberOfDucks);\r\n        }\r\n    }\r\n\r\n    // 오리들이 죽으면 Hunter 선택된 오리를 null로 설정\r\n    private void updateHunterSelectedDucks() {\r\n        Set<Duck> selectedDucksSet = new HashSet<>();\r\n        selectedDucksSet.addAll(Arrays.asList(hunterSelectedDucks));\r\n        selectedDucksSet.addAll(Arrays.asList(playerSelectedDucks));\r\n\r\n        for (int i = 0; i < hunterSelectedDucks.length; i++) {\r\n            if (hunterSelectedDucks[i] == null || !ducks.contains(hunterSelectedDucks[i])) {\r\n                // 새로운 오리를 선택하여 중복되지 않게 추가\r\n                Duck selectedDuck;\r\n                int index;\r\n\r\n                do {\r\n                    index = random.nextInt(ducks.size());\r\n                    selectedDuck = ducks.get(index);\r\n                } while (selectedDucksSet.contains(selectedDuck)); // 중복 방지\r\n\r\n                hunterSelectedDucks[i] = selectedDuck;\r\n                selectedDucksSet.add(selectedDuck);  // 선택된 오리 추가\r\n            }\r\n        }\r\n    }\r\n\r\n    // 더블배럴샷건 모드에서 Player 선택된 오리들에게 sightImg를 그리기\r\n    private void drawSightOnPlayerSelectedDucks(Graphics2D g2d) {\r\n        if (playerSelectedDucks != null) {\r\n            for (Duck duck : playerSelectedDucks) {\r\n                if (duck != null) {\r\n                    g2d.drawImage(sightImg, duck.x, duck.y, null);\r\n                }\r\n            }\r\n        }else{\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    // 더블배럴샷건 모드에서 Hunter 선택된 오리들에게 sightImg를 그리기\r\n    private void drawSightOnHunterSelectedDucks(Graphics2D g2d) {\r\n        if (hunterSelectedDucks != null) {\r\n            for (Duck duck : hunterSelectedDucks) {\r\n                if (duck != null) {\r\n                    g2d.drawImage(sightImg_hunter, duck.x, duck.y,28,28,null);\r\n                }else{\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 더블배럴샷건 모드에서 Hunter 선택된 오리들에게 sightImg를 그리기\r\n    private void drawSightOnFireSelectedDucks(Graphics2D g2d) {\r\n        if (FireSelectedDucks != null) {\r\n            for (Duck duck : FireSelectedDucks) {\r\n                if (duck != null) {\r\n                    g2d.drawImage(sightImg_Fire, duck.x, duck.y,100,100,null);\r\n                }else{\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restart game - reset some variables.\r\n     */\r\n    public void RestartGame() {\r\n        // Removes all of the ducks from this list.\r\n        ducks.clear();\r\n\r\n        // We set last duckt time to zero.\r\n        Duck.setLastDuckTime(0);\r\n\r\n        runawayDucks = 0;\r\n        killedDucks = 0;\r\n        score = 0;\r\n        shoots = 0;\r\n\r\n        lastTimeShoot = 0;\r\n    }\r\n\r\n    public void Pause() {\r\n        ducks.clear();\r\n        isPause = true;\r\n        System.out.println(\"buttonbuyadd\");\r\n        Framework.setGameState(Framework.GameState.PAUSE);\r\n        stopBackgroundMusic();\r\n    }\r\n\r\n    public enum GameState {\r\n        PAUSE, PLAYING, GAME_OVER, MAIN_MENU;\r\n    }\r\n\r\n    public void NextRound() {\r\n        stopBackgroundMusic();\r\n        isPause = false;\r\n        Framework.setGameState(Framework.GameState.PLAYING);\r\n        //Duck.lastDuckTime = 0; // 오리 타이머 초기화\r\n        killedDucks = 0; // 죽인 오리 수 초기화\r\n        runawayDucks = 0; // 도망간 오리 수 초기화\r\n        Round += 1;\r\n        isBossAlive = false;\r\n        roundPass += 30;\r\n        if(Round == 2){\r\n            playBackgroundMusic(\"src/main/resources/sounds/JungleBook.wav\");\r\n        }else if(Round == 3){\r\n            playBackgroundMusic(\"src/main/resources/sounds/FantasticThemePark.wav\");\r\n        }else if(Round == 4){\r\n            playBackgroundMusic(\"src/main/resources/sounds/WhaleBelly.wav\");\r\n        }else if(Round == 5){\r\n            playBackgroundMusic(\"src/main/resources/sounds/TempleOfDarkness.wav\");\r\n        }\r\n\r\n    }\r\n\r\n    public void playActiveSound(String filePath){\r\n        try{\r\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(new File(filePath));\r\n            clip = AudioSystem.getClip();\r\n            clip.open(audioStream);\r\n            clip.start();\r\n        }catch(UnsupportedAudioFileException | IOException | LineUnavailableException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public void stopBackgroundMusic() {\r\n        if (clipbg != null && clipbg.isRunning()) {\r\n            clipbg.stop();\r\n        }\r\n    }\r\n\r\n    public void playBackgroundMusic(String filePath){\r\n        try{\r\n            AudioInputStream audioStream = AudioSystem.getAudioInputStream(new File(filePath));\r\n            clipbg = AudioSystem.getClip();\r\n            clipbg.open(audioStream);\r\n            clipbg.start();\r\n        }catch(UnsupportedAudioFileException | IOException | LineUnavailableException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Update game logic.\r\n     *\r\n     * @param gameTime      gameTime of the game.\r\n     * @param mousePosition current mouse position.\r\n     */\r\n    public void UpdateGame(long gameTime, Point mousePosition) {\r\n        if (isBossAlive) {\r\n            for (int i = 0; i < boss.size(); i++) {\r\n                boss.get(i).update(); // 보스 위치 업데이트\r\n                if (Round == 1) {\r\n                    // 일정 시간마다 공격 발사 (보스 공격 간격 체크)\r\n                    if (System.nanoTime() - lastBossAttackTime >= bossAttackInterval * 1_000_000) {\r\n                        double angle = 150 + Math.random() * 70;\r\n                        double angle2 = 150 + Math.random() * 70;\r\n                        double angle3 = 150 + Math.random() * 70;// 0에서 360도 사이의 랜덤 각도\r\n                        bossAttacks.add(new BossAttack(boss.get(i).x, boss.get(i).y, angle, 15));\r\n                        bossAttacks.add(new BossAttack(boss.get(i).x, boss.get(i).y, angle2, 15));\r\n                        bossAttacks.add(new BossAttack(boss.get(i).x, boss.get(i).y, angle3, 15));// 속도 10으로 설정\r\n                        playActiveSound(BOSSATTCK_SOUND_PATH);\r\n                        lastBossAttackTime = System.nanoTime(); // 마지막 공격 시간 갱신\r\n                    }\r\n                }\r\n\r\n                if (Round == 2) {\r\n                    if (System.nanoTime() - lastBossAttackTime >= bossAttackInterval * 900_000) {\r\n                        double angle1 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle2 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle3 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle4 = Math.toRadians(150 + Math.random() * 70);\r\n                        double gravity = 6;\r\n                        double speed = 150; // Initial speed of the projectile\r\n                        double deltaTime = 0.1;\r\n                        // 각도에 따른 수평 및 수직 속도 계산 (vy는 음수)\r\n                        double vx1 = speed * Math.cos(angle1);\r\n                        double vy1 = speed * Math.sin(angle1); // vy를 음수로 하지 않음 (초기 방향이 위로 향함)\r\n\r\n                        double vx2 = speed * Math.cos(angle2);\r\n                        double vy2 = speed * Math.sin(angle2);\r\n\r\n                        double vx3 = speed * Math.cos(angle3);\r\n                        double vy3 = speed * Math.sin(angle3);\r\n\r\n                        double vx4 = speed * Math.cos(angle3);\r\n                        double vy4 = speed * Math.sin(angle3);\r\n\r\n                        // Add the BossAttacks with initial velocities and positions\r\n                        bossAttacks2.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx1, vy1, gravity, deltaTime));\r\n                        bossAttacks2.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx2, vy2, gravity, deltaTime));\r\n                        bossAttacks2.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx3, vy3, gravity, deltaTime));\r\n                        bossAttacks2.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx4, vy4, gravity, deltaTime));\r\n                        playActiveSound(BOSSATTCK_SOUND_PATH);\r\n                        // Update the time of the last attack\r\n                        lastBossAttackTime = System.nanoTime();\r\n                    }\r\n                }\r\n                if (Round == 3) {\r\n                    if (System.nanoTime() - lastBossAttackTime >= bossAttackInterval * 900_000) {\r\n                        double angle1 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle2 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle3 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle4 = Math.toRadians(150 + Math.random() * 70);\r\n                        double gravity = 6;\r\n                        double speed = 150; // 초기 속도\r\n                        double deltaTime = 0.1;\r\n\r\n                        // 기존 공격 유도탄\r\n                        double vx1 = speed * Math.cos(angle1);\r\n                        double vy1 = speed * Math.sin(angle1);\r\n                        double vx2 = speed * Math.cos(angle2);\r\n                        double vy2 = speed * Math.sin(angle2);\r\n                        double vx3 = speed * Math.cos(angle3);\r\n                        double vy3 = speed * Math.sin(angle3);\r\n                        double vx4 = speed * Math.cos(angle4);\r\n                        double vy4 = speed * Math.sin(angle4);\r\n\r\n                        // 기존 공격 유도탄을 추가\r\n                        bossAttacks3.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx1, vy1, gravity, deltaTime));\r\n                        bossAttacks3.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx2, vy2, gravity, deltaTime));\r\n                        bossAttacks3.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx3, vy3, gravity, deltaTime));\r\n                        bossAttacks3.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx4, vy4, gravity, deltaTime));\r\n\r\n                        // 마우스 위치를 향한 유도탄의 각도 계산\r\n                        double mouseX = mousePosition.getX(); // 마우스 X 좌표를 가져오는 메서드 구현 또는 사용\r\n                        double mouseY = mousePosition.getY(); // 마우스 Y 좌표를 가져오는 메서드 구현 또는 사용\r\n\r\n                        double dx = mouseX - boss.get(i).x;\r\n                        double dy = mouseY - boss.get(i).y;\r\n                        double homingAngle = Math.atan2(dy, dx);\r\n\r\n                        double vxHoming = speed * Math.cos(homingAngle);\r\n                        double vyHoming = speed * Math.sin(homingAngle);\r\n\r\n                        // 유도탄을 추가\r\n                        bossAttacks3.add(new BossAttack(boss.get(i).x, boss.get(i).y, vxHoming, vyHoming, gravity, deltaTime));\r\n                        playActiveSound(BOSSATTCK_SOUND_PATH);\r\n\r\n                        // 마지막 공격 시간 업데이트\r\n                        lastBossAttackTime = System.nanoTime();\r\n                    }\r\n                }if (Round == 4) {\r\n                    // 일반 유도탄 공격 처리\r\n                    if (System.nanoTime() - lastBossAttackTime >= bossAttackInterval * 900_000) {\r\n                        double angle1 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle2 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle3 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle4 = Math.toRadians(150 + Math.random() * 70);\r\n                        double gravity = 6;\r\n                        double speed = 150; // 초기 속도\r\n                        double deltaTime = 0.1;\r\n\r\n                        // 기존 유도탄\r\n                        double vx1 = speed * Math.cos(angle1);\r\n                        double vy1 = speed * Math.sin(angle1);\r\n                        double vx2 = speed * Math.cos(angle2);\r\n                        double vy2 = speed * Math.sin(angle2);\r\n                        double vx3 = speed * Math.cos(angle3);\r\n                        double vy3 = speed * Math.sin(angle3);\r\n                        double vx4 = speed * Math.cos(angle4);\r\n                        double vy4 = speed * Math.sin(angle4);\r\n\r\n                        // 기존 유도탄 추가\r\n                        bossAttacks4.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx1, vy1, gravity, deltaTime));\r\n                        bossAttacks4.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx2, vy2, gravity, deltaTime));\r\n                        bossAttacks4.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx3, vy3, gravity, deltaTime));\r\n                        bossAttacks4.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx4, vy4, gravity, deltaTime));\r\n\r\n                        // 마우스 위치를 향한 유도탄의 각도 계산\r\n                        double mouseX = mousePosition.getX(); // 마우스 X 좌표를 가져오는 메서드 구현 또는 사용\r\n                        double mouseY = mousePosition.getY(); // 마우스 Y 좌표를 가져오는 메서드 구현 또는 사용\r\n\r\n                        double dx = mouseX - boss.get(i).x;\r\n                        double dy = mouseY - boss.get(i).y;\r\n                        double homingAngle = Math.atan2(dy, dx);\r\n\r\n                        double vxHoming = speed * Math.cos(homingAngle);\r\n                        double vyHoming = speed * Math.sin(homingAngle);\r\n\r\n                        // 유도탄을 추가\r\n                        bossAttacks4.add(new BossAttack(boss.get(i).x, boss.get(i).y, vxHoming, vyHoming, gravity, deltaTime));\r\n                        bossAttacks4.add(new BossAttack(boss.get(i).x, boss.get(i).y, vxHoming, vyHoming, gravity, deltaTime));\r\n                        playActiveSound(BOSSATTCK_SOUND_PATH);\r\n\r\n                        // 마지막 공격 시간 업데이트\r\n                        lastBossAttackTime = System.nanoTime();\r\n                    }\r\n\r\n                    // 밑에서 올라오는 탄환 처리\r\n                    if (System.nanoTime() - lastBottomAttackTime >= bottomAttackInterval * 900_000) {\r\n                        double gravity = 6;\r\n                        double speed = 150; // 초기 속도\r\n                        double deltaTime = 0.1;\r\n\r\n                        // 화면 아래쪽에서 시작하도록 위치 설정 (예: 아래 중앙)\r\n                        double screenBottomX1 = framework.getWidth() / 2.0; // 화면 중앙 X 좌표\r\n                        double screenBottomX2 = framework.getWidth() * (0.11 + Math.random() * (0.33 - 0.11)); // 왼쪽에서 나오는 탄환\r\n                        double screenBottomX3 = framework.getWidth() * (0.11 + Math.random() * (0.33 - 0.11)); // 오른쪽에서 나오는 탄환\r\n                        double screenBottomY = framework.getHeight(); // 화면의 아래 Y 좌표\r\n\r\n                        // 위쪽으로 일정한 각도로 발사되는 일반 탄환\r\n                        double upwardAngle = Math.toRadians(80 + Math.random()*(90 - 80)); // 정확히 위쪽으로\r\n\r\n                        // 각 탄환의 속도 계산\r\n                        double vxUp1 = speed * Math.cos(upwardAngle);\r\n                        double vyUp1 = -speed * Math.sin(upwardAngle);\r\n                        System.out.println(screenBottomY+\"aaaaaa\"+screenBottomX3+\"aaaa\"+vyUp1);\r\n                        // 일반 탄환을 추가\r\n                        bossAttacks4.add(new BossAttack((int)screenBottomX1, (int)screenBottomY, vxUp1, vyUp1, gravity, deltaTime));\r\n                        bossAttacks4.add(new BossAttack((int)screenBottomX2, (int)screenBottomY, vxUp1, vyUp1, gravity, deltaTime));\r\n                        bossAttacks4.add(new BossAttack((int)screenBottomX3, (int)screenBottomY, vxUp1, vyUp1, gravity, deltaTime));\r\n\r\n                        // 마지막 밑에서 올라오는 공격 시간 업데이트\r\n                        lastBottomAttackTime = System.nanoTime();\r\n                    }\r\n                }if (Round == 5) {\r\n                    // 일반 유도탄 공격 처리\r\n                    if (System.nanoTime() - lastBossAttackTime >= bossAttackInterval * 900_000) {\r\n                        double angle1 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle2 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle3 = Math.toRadians(150 + Math.random() * 70);\r\n                        double angle4 = Math.toRadians(150 + Math.random() * 70);\r\n                        double gravity = 6;\r\n                        double speed = 150; // 초기 속도\r\n                        double deltaTime = 0.1;\r\n\r\n                        // 기존 유도탄\r\n                        double vx1 = speed * Math.cos(angle1);\r\n                        double vy1 = speed * Math.sin(angle1);\r\n                        double vx2 = speed * Math.cos(angle2);\r\n                        double vy2 = speed * Math.sin(angle2);\r\n                        double vx3 = speed * Math.cos(angle3);\r\n                        double vy3 = speed * Math.sin(angle3);\r\n                        double vx4 = speed * Math.cos(angle4);\r\n                        double vy4 = speed * Math.sin(angle4);\r\n\r\n                        // 기존 유도탄 추가\r\n                        bossAttacks5.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx1, vy1, gravity, deltaTime));\r\n                        bossAttacks5.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx2, vy2, gravity, deltaTime));\r\n                        bossAttacks5.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx3, vy3, gravity, deltaTime));\r\n                        bossAttacks5.add(new BossAttack(boss.get(i).x, boss.get(i).y, vx4, vy4, gravity, deltaTime));\r\n\r\n                        // 마우스 위치를 향한 유도탄의 각도 계산\r\n                        double mouseX = mousePosition.getX(); // 마우스 X 좌표를 가져오는 메서드 구현 또는 사용\r\n                        double mouseY = mousePosition.getY(); // 마우스 Y 좌표를 가져오는 메서드 구현 또는 사용\r\n\r\n                        double dx = mouseX - boss.get(i).x;\r\n                        double dy = mouseY - boss.get(i).y;\r\n                        double homingAngle = Math.atan2(dy, dx);\r\n\r\n                        double vxHoming = speed * Math.cos(homingAngle);\r\n                        double vyHoming = speed * Math.sin(homingAngle);\r\n\r\n                        // 유도탄을 추가\r\n                        bossAttacks5.add(new BossAttack(boss.get(i).x, boss.get(i).y, vxHoming, vyHoming, gravity, deltaTime));\r\n                        bossAttacks5.add(new BossAttack(boss.get(i).x, boss.get(i).y, vxHoming, vyHoming, gravity, deltaTime));\r\n                        playActiveSound(BOSSATTCK_SOUND_PATH);\r\n\r\n                        // 마지막 공격 시간 업데이트\r\n                        lastBossAttackTime = System.nanoTime();\r\n                    }\r\n\r\n                    // 밑에서 올라오는 탄환 처리\r\n                    if (System.nanoTime() - lastBottomAttackTime >= bottomAttackInterval * 900_000) {\r\n                        double gravity = 6;\r\n                        double speed = 150; // 초기 속도\r\n                        double deltaTime = 0.1;\r\n\r\n                        // 화면 아래쪽에서 시작하도록 위치 설정 (예: 아래 중앙)\r\n                        double screenBottomX1 = framework.getWidth() / 2.0; // 화면 중앙 X 좌표\r\n                        double screenBottomX2 = framework.getWidth() * (0.11 + Math.random() * (0.33 - 0.11)); // 왼쪽에서 나오는 탄환\r\n                        double screenBottomX3 = framework.getWidth() * (0.11 + Math.random() * (0.33 - 0.11)); // 오른쪽에서 나오는 탄환\r\n                        double screenBottomY = framework.getHeight(); // 화면의 아래 Y 좌표\r\n                        double screenTopY = 0;\r\n\r\n                        // 위쪽으로 일정한 각도로 발사되는 일반 탄환\r\n                        double upwardAngle = Math.toRadians(80 + Math.random()*(90 - 80)); // 정확히 위쪽으로\r\n\r\n                        // 각 탄환의 속도 계산\r\n                        double vxUp1 = speed * Math.cos(upwardAngle);\r\n                        double vyUp1 = -speed * Math.sin(upwardAngle);\r\n                        double vyDown1 = speed * Math.sin(upwardAngle);\r\n                        System.out.println(screenBottomY+\"aaaaaa\"+screenBottomX3+\"aaaa\"+vyUp1);\r\n                        // 일반 탄환을 추가\r\n                        bossAttacks5.add(new BossAttack((int)screenBottomX1, (int)screenBottomY, vxUp1, vyUp1, gravity, deltaTime));\r\n                        bossAttacks5.add(new BossAttack((int)screenBottomX2, (int)screenBottomY, vxUp1, vyUp1, gravity, deltaTime));\r\n                        bossAttacks5.add(new BossAttack((int)screenBottomX3, (int)screenBottomY, vxUp1, vyUp1, gravity, deltaTime));\r\n                        bossAttacks5.add(new BossAttack((int)screenBottomX3, (int)screenTopY, vxUp1, vyDown1, gravity, deltaTime));\r\n                        bossAttacks5.add(new BossAttack((int)screenBottomX2, (int)screenTopY, vxUp1, vyDown1, gravity, deltaTime));\r\n\r\n                        // 마지막 밑에서 올라오는 공격 시간 업데이트\r\n                        lastBottomAttackTime = System.nanoTime();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 보스 공격 업데이트 및 피격 체크\r\n            for (int i = 0; i < bossAttacks.size(); i++) {\r\n                if (Round == 1) {\r\n                    BossAttack attack = bossAttacks.get(i);\r\n                    attack.update(); // 공격 위치 업데이트\r\n\r\n                    // 피격 범위 확인\r\n                    if (attack.isHit(mousePosition)) {\r\n                        System.out.println(HIT_MESSAGE);\r\n                        bossAttacks.remove(i);// 공격이 맞았으므로 제거\r\n                        PlayerHp -= 10;\r\n                        playActiveSound(HIT_SOUND_PATH);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n\r\n                    // 화면 밖으로 나간 공격은 제거\r\n                    if (attack.x < 0 || attack.x > framework.getWidth() || attack.y < 0 || attack.y > framework.getHeight()) {\r\n                        bossAttacks.remove(i);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n                }\r\n            }\r\n            for(int i = 0; i < bossAttacks2.size(); i++){\r\n                if(Round==2){\r\n                    BossAttack attack2 = bossAttacks2.get(i);\r\n                    attack2.updatewithgravity();\r\n\r\n                    if (attack2.isHit(mousePosition)) {\r\n                        System.out.println(HIT_MESSAGE);\r\n                        bossAttacks2.remove(i);// 공격이 맞았으므로 제거\r\n                        PlayerHp -= 10;\r\n                        playActiveSound(HIT_SOUND_PATH);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n\r\n                    // 화면 밖으로 나간 공격은 제거\r\n                    if (attack2.x < 0 || attack2.x > framework.getWidth() || attack2.y < 0 || attack2.y > framework.getHeight()) {\r\n                        bossAttacks2.remove(i);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n                }\r\n            }  for(int i = 0; i < bossAttacks3.size(); i++){\r\n                if(Round==3){\r\n                    BossAttack attack2 = bossAttacks3.get(i);\r\n                    attack2.updatewithgravity();\r\n\r\n                    if (attack2.isHit(mousePosition)) {\r\n                        System.out.println(HIT_MESSAGE);\r\n                        bossAttacks3.remove(i);// 공격이 맞았으므로 제거\r\n                        PlayerHp -= 10;\r\n                        playActiveSound(HIT_SOUND_PATH);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n\r\n                    // 화면 밖으로 나간 공격은 제거\r\n                    if (attack2.x < 0 || attack2.x > framework.getWidth() || attack2.y < 0 || attack2.y > framework.getHeight()) {\r\n                        bossAttacks3.remove(i);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n                }\r\n            }for(int i = 0; i < bossAttacks4.size(); i++){\r\n                if(Round==4){\r\n                    BossAttack attack2 = bossAttacks4.get(i);\r\n                    attack2.updatewithgravity();\r\n                    attack2.update();\r\n                    if (attack2.isHit(mousePosition)) {\r\n                        System.out.println(HIT_MESSAGE);\r\n                        bossAttacks4.remove(i);// 공격이 맞았으므로 제거\r\n                        PlayerHp -= 10;\r\n                        playActiveSound(HIT_SOUND_PATH);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n\r\n                    // 화면 밖으로 나간 공격은 제거\r\n                    if (attack2.x < 0 || attack2.x > framework.getWidth() || attack2.y < 0 || attack2.y > framework.getHeight()) {\r\n                        bossAttacks4.remove(i);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n                }\r\n            }for(int i = 0; i < bossAttacks5.size(); i++){\r\n                if(Round==5){\r\n                    BossAttack attack2 = bossAttacks5.get(i);\r\n                    attack2.updatewithgravity();\r\n\r\n                    if (attack2.isHit(mousePosition)) {\r\n                        System.out.println(HIT_MESSAGE);\r\n                        bossAttacks5.remove(i);// 공격이 맞았으므로 제거\r\n                        PlayerHp -= 10;\r\n                        playActiveSound(HIT_SOUND_PATH);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n\r\n                    // 화면 밖으로 나간 공격은 제거\r\n                    if (attack2.x < 0 || attack2.x > framework.getWidth() || attack2.y < 0 || attack2.y > framework.getHeight()) {\r\n                        bossAttacks5.remove(i);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        if(Hunter1&& hunterTrigger && !isPause){\r\n            startHunterAutoKill(2500);\r\n            hunterTrigger = false;\r\n        }else if(!Hunter1){\r\n        }else if(!hunterTrigger){\r\n\r\n        }\r\n        if(!isPause) {\r\n            int maxGiftBoxes = 1;\r\n            int Random = 1+(int)(Math.random()*1000);\r\n            // Creates a new duck, if it's the time, and add it to the array list.\r\n            // 랜덤한 간격으로 선물 상자를 생성\r\n            if (System.nanoTime() - lastGiftBoxTime >= giftBoxInterval * 1_000_000) {\r\n                if ((giftBoxes.size() < maxGiftBoxes) && Random == 50) {\r\n                    int randomX = (int) (Math.random() * (framework.getWidth() - 50)); // 랜덤 X 좌표 (상자 크기를 고려)\r\n                    int fallSpeed = 5 + (int) (Math.random() * 5); // 5~10 사이의 낙하 속도\r\n\r\n                    // 랜덤한 타입 선택 (1, 2, 3)\r\n                    int giftBoxType = 1 + (int) (Math.random() * 3);\r\n\r\n                    // 타입에 따라 이미지 선택\r\n                    BufferedImage selectedImg = giftBoxImg1;\r\n                    if (giftBoxType == 2) {\r\n                        selectedImg = giftBoxImg2;\r\n                    } else if (giftBoxType == 3) {\r\n                        selectedImg = giftBoxImg3;\r\n                    }\r\n\r\n                    // 새로운 선물 상자 추가\r\n                    giftBoxes.add(new GiftBox(randomX, 0, 150, 150, fallSpeed, giftBoxType, selectedImg));\r\n\r\n                    // 마지막 생성 시간 갱신 및 다음 생성 간격을 랜덤하게 설정\r\n                    lastGiftBoxTime = System.nanoTime();\r\n                    giftBoxInterval = getRandomInterval(minInterval, maxInterval);\r\n                }\r\n            }\r\n\r\n            // 상자 업데이트 및 충돌 체크\r\n            for (int i = 0; i < giftBoxes.size(); i++) {\r\n                giftBoxes.get(i).update();\r\n\r\n                // 플레이어와 충돌 체크\r\n                if (new Rectangle(giftBoxes.get(i).x + 18, giftBoxes.get(i).y, 150, 150).contains(mousePosition)\r\n                        && Canvas.mouseButtonState(MouseEvent.BUTTON1)) {\r\n                    System.out.println(\"Player collected a gift!\");\r\n\r\n                    // 선물 상자의 타입에 따라 다른 보상 제공\r\n                    if (giftBoxes.get(i).type == 1) {\r\n                        startFireAutoKill(1500);\r\n                        System.out.println(\"Fire\");\r\n                        fire = true;\r\n                        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\r\n                        scheduler.schedule(() -> {\r\n                            stopFireAutoKill();\r\n                            fire = false;\r\n                        }, 9000, TimeUnit.SECONDS);// 3초 후 실행/ 1번 상자: 돈 증가\r\n                    } else if (giftBoxes.get(i).type == 2) {\r\n                        // 모든 오리의 속도를 증가시키기\r\n                        System.out.println(\"speed\");\r\n                        for (Duck duck : ducks) {\r\n                            int currentSpeed = duck.getSpeed();\r\n                            System.out.println(currentSpeed);\r\n                            if(currentSpeed > -3 ) {\r\n                                duck.setSpeed(currentSpeed + 1);\r\n                            }// 기존 속도보다 1씩 증가\r\n                        }\r\n                        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\r\n                        scheduler.schedule(() -> {\r\n                            for (Duck duck : ducks) {\r\n                                int currentSpeed = duck.getSpeed();\r\n                                if(currentSpeed > -4) {\r\n                                    duck.setSpeed(currentSpeed - 1);\r\n                                }// 기존 속도보다 1씩 증가\r\n                            }\r\n                        }, 3, TimeUnit.SECONDS);// 3초 후 실행\r\n                    } else if (giftBoxes.get(i).type == 3) {\r\n                        PlayerHp += 10; // 3번 상자: 체력 증가\r\n                    }\r\n\r\n                    // 충돌한 상자는 제거\r\n                    giftBoxes.remove(i);\r\n                    i--; // 인덱스 조정\r\n                }\r\n\r\n                // 화면 밖으로 벗어난 상자 제거\r\n                if(giftBoxes.size() > 0) {\r\n                    if (giftBoxes.get(i).y > framework.getHeight()) {\r\n                        giftBoxes.remove(i);\r\n                        i--; // 인덱스 조정\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (System.nanoTime() - Duck.lastDuckTime >= Duck.timeBetweenDucks) {\r\n\r\n                if (isReloading) {\r\n                    if (System.nanoTime() - reloadStartTime >= reloadDuration) {\r\n                        ammo = maxAmmo;   // 탄약을 최대치로 채움\r\n                        isReloading = false; // 장전 상태 해제\r\n                    }\r\n                }\r\n                if(ammo<=0 && !isReloading){\r\n                    Reload();\r\n                }\r\n\r\n                if (framework.getGun().equals(\"더블배럴샷건\")) {\r\n                    selectPlayerDucks(1);\r\n                    // 선택된 오리들이 죽었는지 확인하고, 죽으면 다시 선택\r\n                }else if(framework.getGun().equals(\"기본권총\")){\r\n\r\n                }\r\n                // Here we create new duck and add it to the array list.\r\n                ducks.add(new Duck(Duck.duckLines[Duck.nextDuckLines][0] + random.nextInt(200), Duck.duckLines[Duck.nextDuckLines][1], Duck.duckLines[Duck.nextDuckLines][2], Duck.duckLines[Duck.nextDuckLines][3],duckImg));\r\n\r\n                // Here we increase nextDuckLines so that next duck will be created in next line.\r\n                Duck.incrementNextDuckLines();\r\n                if (Duck.nextDuckLines >= Duck.duckLines.length)\r\n                    Duck.resetNextDuckLines();\r\n\r\n                if (killedDucks >= roundPass && !isBossAlive) {\r\n                    // 보스 생성\r\n                    stopBackgroundMusic();\r\n                    playBackgroundMusic(\"src/main/resources/sounds/warning.wav\");\r\n                    spawnBossWithDelay();\r\n                    Bosswith3delay = true;\r\n                    isBossAlive = true; // 보스가 등장했음을 표시\r\n                    System.out.println(\"boss activity\");\r\n                    endingStartTime = System.nanoTime();\r\n                    ducks.clear();\r\n                }\r\n                Duck.setLastDuckTime(System.nanoTime());\r\n            }\r\n\r\n            if(!isBossAlive) {\r\n                // Update all of the ducks.\r\n                for (int i = 0; i < ducks.size(); i++) {\r\n                    // Move the duck.\r\n                    ducks.get(i).Update();\r\n\r\n                    // Checks if the duck leaves the screen and remove it if it does.\r\n                    if (ducks.get(i).x < 0 - duckImg.getWidth()) {\r\n                        ducks.remove(i);\r\n                        runawayDucks++;\r\n                    }\r\n                }\r\n                // Does player shoots?\r\n                if (Canvas.mouseButtonState(MouseEvent.BUTTON1) && !isReloading) {\r\n                    if (System.nanoTime() - lastTimeShoot >= timeBetweenShots) {\r\n                        shoots++;\r\n                        playActiveSound(\"src/main/resources/sounds/gun.wav\");\r\n                        ammo--;\r\n                        if (playerSelectedDucks != null) {\r\n                            for (int i = 0; i < playerSelectedDucks.length; i++) {\r\n                                if (playerSelectedDucks[i] != null) {\r\n                                    playActiveSound(\"src/main/resources/sounds/quack.wav\");\r\n                                    killedDucks++; // 죽인 오리 수 증가\r\n                                    money += 10; // 돈 증가\r\n                                    score += playerSelectedDucks[i].score; // 점수 증가\r\n                                    // 오리 리스트에서 제거\r\n                                    ducks.remove(playerSelectedDucks[i]);\r\n\r\n                                    // 선택된 오리를 null로 설정하여 초기화\r\n                                    playerSelectedDucks[i] = null;\r\n                                    updateAndReselectPlayerDucks(1);\r\n                                }\r\n                            }\r\n                        }\r\n                        // We go over all the ducks and we look if any of them was shoot.\r\n                        for (int i = 0; i < ducks.size(); i++) {\r\n                            // We check, if the mouse was over ducks head or body, when player has shot.\r\n                            if (new Rectangle(ducks.get(i).x + 18, ducks.get(i).y, 27, 30).contains(mousePosition) ||\r\n                                    new Rectangle(ducks.get(i).x + 30, ducks.get(i).y + 30, 88, 25).contains(mousePosition)) {\r\n                                killedDucks++;\r\n                                money += 10;\r\n                                score += ducks.get(i).score;\r\n                                playActiveSound(\"src/main/resources/sounds/quack.wav\");\r\n\r\n                                // Remove the duck from the array list.\r\n                                ducks.remove(i);\r\n\r\n                                // We found the duck that player shoot so we can leave the for loop.\r\n                                break;\r\n                            }\r\n                        }\r\n                        // We go over all the bosses and we look if any of them was shoot.\r\n                        // We go over all the bosses and we look if any of them was shoot.\r\n\r\n\r\n                        lastTimeShoot = System.nanoTime();\r\n                    }\r\n                }\r\n            }else {\r\n\r\n                if (Canvas.mouseButtonState(MouseEvent.BUTTON1) && !isReloading) {\r\n                    if (System.nanoTime() - lastTimeShoot >= timeBetweenShots) {\r\n                        shoots++;\r\n                        ammo--;\r\n                        if (isBossAlive) {\r\n                            for (int i = 0; i < boss.size(); i++) {\r\n                                // Define the boss hitbox (for exampl, a larger area for the boss).\r\n                                // 보스가 랜덤 각도로 공격 발사\r\n                                if (new Rectangle(boss.get(i).x, boss.get(i).y, 378, 268).contains(mousePosition)) {\r\n                                    // Reduce boss health\r\n                                    playActiveSound(\"src/main/resources/sounds/gun.wav\");\r\n                                    boss.get(i).health -= damage; // Reduce boss health by 20 on each hit.\r\n                                    System.out.println(\"attack boss\");\r\n                                    System.out.println(boss.get(i).health);\r\n                                    // If the boss is dead, update score, money, etc.\r\n                                    if (boss.get(i).health <= 0) {\r\n                                        money += 100; // Bosses give more money\r\n                                        score += boss.get(i).score; // Boss-specific score\r\n                                        boss.remove(i);\r\n                                        if (Round == 5) {\r\n                                            Framework.GameState currentState = Framework.getGameState();\r\n                                            stopBackgroundMusic();\r\n                                            endingStartTime = System.currentTimeMillis();\r\n                                            framework.saveScore(score);\r\n                                            framework.saveScore(score);\r\n                                            leaderboardSaved = true;\r\n                                            playBackgroundMusic(\"src/main/resources/sounds/NewBeginningNotTheEnd.wav\"); // 엔딩 테마곡 재생\r\n                                        } else {\r\n                                            Pause(); // 다른 라운드의 경우 일시 정지 상태로 전환\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                    // Since a boss was hit, we can leave the loop.\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    lastTimeShoot = System.nanoTime();\r\n                }\r\n            }\r\n\r\n            // When 200 ducks runaway, the game ends.\r\n            if (runawayDucks >= 10 || PlayerHp < 0 )\r\n                Framework.setGameState(Framework.GameState.GAMEOVER);\r\n            if (Framework.gameState == Framework.GameState.GAMEOVER && !leaderboardSaved) {\r\n                framework.saveScore(score);\r\n                framework.saveMoney(score);\r\n                leaderboardSaved = true;  // 리더보드 저장 완료\r\n            }\r\n        }\r\n        if(isPause) {\r\n            hunterTrigger = true;\r\n            stopHunterAutoKill();\r\n            buttonbuy.add(new Buttonbuy(framework.getWidth()/2 - 350, framework.getHeight()/2+50, buttonImg));\r\n            buttonbuy.add(new Buttonbuy(framework.getWidth()/2 -50, framework.getHeight()/2+50, buttonImg));\r\n            buttonbuy.add(new Buttonbuy(framework.getWidth()/2 + 250, framework.getHeight()/2+50, buttonImg));\r\n            // 마우스 포지션 및 버튼 클릭 상태 확인\r\n            boolean mouseClicked = false;\r\n            if (Canvas.mouseButtonState(MouseEvent.BUTTON1) && !mouseClicked) {\r\n                mouseClicked = true;\r\n                if(!Canvas.mouseButtonState(MouseEvent.BUTTON1)) {\r\n                    mouseClicked = false;\r\n                }\r\n                // 버튼 1 (헌터 구매)\r\n                if (money > 200 && Hunters.size() < 1) {\r\n                    Rectangle buttonArea1 = new Rectangle(buttonbuy.get(0).x, buttonbuy.get(0).y, 367, 257);\r\n                    if (buttonArea1.contains(mousePosition) && mouseClicked) {\r\n                        System.out.println(BUY_BUTTON_MESSAGE);\r\n                        Hunters.add(new Hunter1(220, 290, 0, 100, hunter111Img));\r\n                        Hunter1 = true;\r\n                        money -= 200;\r\n                        System.out.println(MOUSE_POSITION_MESSAGE + mousePosition);\r\n                        System.out.println(BUTTON_POSITION_MESSAGE + buttonbuy.get(0).x + \", \" + buttonbuy.get(0).y);\r\n                    }\r\n                }\r\n\r\n                // 버튼 2 (데미지 증가)\r\n                if (money > 100) {\r\n                    Rectangle buttonArea2 = new Rectangle(buttonbuy.get(1).x, buttonbuy.get(1).y, 367, 257);\r\n                    if (buttonArea2.contains(mousePosition)&& mouseClicked) {\r\n                        System.out.println(BUY_BUTTON_MESSAGE);\r\n                        damage += 10;\r\n                        money -= 100;\r\n                        System.out.println(MOUSE_POSITION_MESSAGE + mousePosition);\r\n                        System.out.println(BUTTON_POSITION_MESSAGE + buttonbuy.get(1).x + \", \" + buttonbuy.get(1).y);\r\n                    }\r\n                }\r\n\r\n                // 버튼 3 (최대 탄약 증가)\r\n                if (money > 100) {\r\n                    Rectangle buttonArea3 = new Rectangle(buttonbuy.get(2).x, buttonbuy.get(2).y, 367, 257);\r\n                    if (buttonArea3.contains(mousePosition) && mouseClicked) {\r\n                        System.out.println(BUY_BUTTON_MESSAGE);\r\n                        maxAmmo += 2;\r\n                        money -= 100;\r\n                        System.out.println(MOUSE_POSITION_MESSAGE + mousePosition);\r\n                        System.out.println(BUTTON_POSITION_MESSAGE + buttonbuy.get(2).x + \", \" + buttonbuy.get(2).y);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if(Hunters.size() > 0) {\r\n            Hunter1 = true;\r\n        }\r\n    }\r\n\r\n    public void drawBossAttack(Graphics2D g2d){\r\n        for(int i = 0; i < bossAttacks.size(); i++) {\r\n            g2d.drawImage(bossAttack, bossAttacks.get(i).x,bossAttacks.get(i).y, null );\r\n        }\r\n    }\r\n    private void spawnBossWithDelay() {\r\n        // 3초 후 보스 생성\r\n        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\r\n        scheduler.schedule(() -> {\r\n            if(Round == 1){\r\n                boss.add(new boss1(1200, 400, 0, 1000,200,bossImg));\r\n            }else if(Round == 2){\r\n                boss.add(new boss1(1200,400,0,1500, 400,boss2Img));\r\n            }else if(Round == 3){\r\n                boss.add(new boss1(1200,400, 0, 2000, 2500,boss3Img));\r\n            }else if(Round == 4){\r\n                boss.add(new boss1(1200,400,0,3000, 6400, boss4Img));\r\n            }else if(Round == 5){\r\n                boss.add(new boss1(1200,400,0,4000, 12000, boss5Img));\r\n            }\r\n            stopBackgroundMusic();\r\n            if(Round == 1) {\r\n                playBackgroundMusic(\"src/main/resources/sounds/AquaCave.wav\");\r\n            }else if(Round == 2){\r\n                playBackgroundMusic(\"src/main/resources/sounds/RuinCastle.wav\");\r\n            }else if(Round == 3){\r\n                playBackgroundMusic(\"src/main/resources/sounds/ArabPirate.wav\");\r\n            }else if(Round == 4){\r\n                playBackgroundMusic(\"src/main/resources/sounds/SinkingThings.wav\");\r\n            }else if(Round == 5){\r\n                playBackgroundMusic(\"src/main/resources/sounds/WorldHorizon.wav\");\r\n            }\r\n            isBossAlive = true; // 보스가 등장했음을 표시\r\n            System.out.println(\"Boss activity\");\r\n            ducks.clear();\r\n            Bosswith3delay = false;\r\n        }, 3, TimeUnit.SECONDS); // 3초 후 실행\r\n    }\r\n\r\n    /**\r\n     * Draw the game to the screen.\r\n     *\r\n     * @param g2d Graphics2D\r\n     * @param mousePosition current mouse position.\r\n     */\r\n\r\n    public void Draw(Graphics2D g2d, Point mousePosition) {\r\n        drawBackground(g2d);\r\n        drawDucks(g2d);\r\n        drawBossWarning(g2d);\r\n        drawHunter1(g2d);\r\n        drawBossAttacks(g2d);\r\n        drawBoss(g2d);\r\n        drawButtonsAndShop(g2d);\r\n        drawGiftBoxes(g2d);\r\n        configureGunSettings(g2d);\r\n        drawGunSightAndReloadStatus(g2d, mousePosition);\r\n        drawHUD(g2d);\r\n    }\r\n\r\n    // 배경 그리기\r\n    private void drawBackground(Graphics2D g2d) {\r\n        Image[] backgrounds = { backgroundImg, backgroundImg2, backgroundImg3, backgroundImg4, backgroundImg5 };\r\n        if (Round >= 1 && Round <= 5) {\r\n            g2d.drawImage(backgrounds[Round - 1], 0, 0, Framework.frameWidth, Framework.frameHeight, null);\r\n        }\r\n    }\r\n\r\n    // 모든 오리 그리기\r\n    private void drawDucks(Graphics2D g2d) {\r\n        for (int i = 0; i < ducks.size(); i++) {\r\n            ducks.get(i).Draw(g2d);\r\n        }\r\n    }\r\n\r\n    // 보스 공격 경고 그리기\r\n    private void drawBossWarning(Graphics2D g2d) {\r\n        if (Bosswith3delay) {\r\n            g2d.drawImage(warningImg, Framework.frameWidth / 2 - 275, Framework.frameHeight / 2 - 250, null);\r\n        }\r\n    }\r\n\r\n    // 헌터1 그리기 및 관련 처리\r\n    private void drawHunter1(Graphics2D g2d) {\r\n        if (Hunter1) {\r\n            g2d.drawImage(hunter111Img, Hunters.get(0).x, Hunters.get(0).y, null);\r\n            drawSightOnHunterSelectedDucks(g2d);\r\n        }\r\n    }\r\n\r\n    // 보스 공격 처리 (보스 공격 목록 및 이미지 그리기)\r\n    private void drawBossAttacks(Graphics2D g2d) {\r\n        List<List<BossAttack>> bossAttackLists = Arrays.asList(bossAttacks, bossAttacks2, bossAttacks3, bossAttacks4, bossAttacks5);\r\n        List<Image> bossAttackImages = Arrays.asList(bossAttack, bossAttack2, bossAttack3, bossAttack4, bossAttack5);\r\n\r\n        for (int i = 0; i < bossAttackLists.size(); i++) {\r\n            List<BossAttack> currentList = bossAttackLists.get(i);\r\n            Image currentImage = bossAttackImages.get(i);\r\n\r\n            if (currentList.size() > 0) {\r\n                for (BossAttack attack : currentList) {\r\n                    g2d.drawImage(currentImage, attack.x, attack.y, 100, 100, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 보스 그리기 및 HP 바 그리기\r\n    private void drawBoss(Graphics2D g2d) {\r\n        if (!boss.isEmpty()) {\r\n            for (int i = 0; i < boss.size(); i++) {\r\n                BufferedImage bossImage = getBossImageForRound();\r\n                if (bossImage != null) {\r\n                    g2d.drawImage(bossImage, boss.get(i).x - 90, boss.get(i).y - 20, 378, 268, null);\r\n                }\r\n\r\n                drawBossHealthBar(g2d, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    private BufferedImage getBossImageForRound() {\r\n        switch (Round) {\r\n            case 1: return bossImg;\r\n            case 2: return boss2Img;\r\n            case 3: return boss3Img;\r\n            case 4: return boss4Img;\r\n            case 5: return boss5Img;\r\n            default: System.err.println(\"Warning: Unexpected gift box type: \" + Round); return null;\r\n        }\r\n    }\r\n\r\n    private void drawBossHealthBar(Graphics2D g2d, int i) {\r\n        int currentHealth = boss.get(i).health;\r\n        int maxHealth = boss.get(i).maxHealth;\r\n        int hpIndex = (int) ((currentHealth / (double) maxHealth) * 11);\r\n        hpIndex = Math.max(0, Math.min(11, hpIndex));\r\n\r\n        int hpBarWidth = hpImages[hpIndex].getWidth(null) / 8;\r\n        int hpBarHeight = hpImages[hpIndex].getHeight(null) / 8;\r\n        g2d.drawImage(hpImages[hpIndex], boss.get(i).x - 20, boss.get(i).y - 60, hpBarWidth, hpBarHeight, null);\r\n    }\r\n\r\n    // 버튼과 상점 그리기\r\n    private void drawButtonsAndShop(Graphics2D g2d) {\r\n        if (isPause) {\r\n            int buyWidth = buttonImg.getWidth(null) / 2;\r\n            int buyHeight = buttonImg.getHeight(null) / 2;\r\n            for (int i = 0; i < buttonbuy.size(); i++) {\r\n                g2d.drawImage(buttonImg, buttonbuy.get(i).x, buttonbuy.get(i).y, buyWidth, buyHeight, null);\r\n                if (i < shopImages.length) {\r\n                    g2d.drawImage(shopImages[i], buttonbuy.get(i).x - 60, buttonbuy.get(i).y - 250, 300, 300, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 선물 상자 그리기\r\n    private void drawGiftBoxes(Graphics2D g2d) {\r\n        if (giftBoxes != null) {\r\n            for (GiftBox giftBox : giftBoxes) {\r\n                BufferedImage selectedImg = getGiftBoxImage(giftBox.type);\r\n                if (selectedImg != null) {\r\n                    g2d.drawImage(selectedImg, giftBox.x, giftBox.y, giftBox.width, giftBox.height, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private BufferedImage getGiftBoxImage(int type) {\r\n        switch (type) {\r\n            case 1: return giftBoxImg1;\r\n            case 2: return giftBoxImg2;\r\n            case 3: return giftBoxImg3;\r\n            default:\r\n                System.err.println(\"Warning: Unexpected gift box type: \" + type);\r\n                return null;\r\n        }\r\n    }\r\n\r\n    // 총기 설정\r\n    private void configureGunSettings(Graphics2D g2d) {\r\n        if (framework.getGun().equals(\"더블배럴샷건\")) {\r\n            drawSightOnPlayerSelectedDucks(g2d);\r\n            reloadDuration = 2500000000L;\r\n        } else if (framework.getGun().equals(\"AK-47\")) {\r\n            maxAmmo = 30;\r\n            reloadDuration = 3000000000L;\r\n            timeBetweenShots = 100_000_000L;\r\n        }\r\n    }\r\n\r\n    // 총기 조준선과 리로드 상태 그리기\r\n    private void drawGunSightAndReloadStatus(Graphics2D g2d, Point mousePosition) {\r\n        if (fire) {\r\n            drawSightOnFireSelectedDucks(g2d);\r\n        }\r\n        if (isReloading) {\r\n            g2d.drawString(\"Reloading\", Framework.frameWidth / 2, Framework.frameHeight / 2);\r\n        }\r\n\r\n        g2d.drawImage(sightImg, mousePosition.x - sightImgMiddleWidth, mousePosition.y - sightImgMiddleHeight, null);\r\n    }\r\n\r\n    // HUD (Heads-Up Display) 그리기\r\n    private void drawHUD(Graphics2D g2d) {\r\n        g2d.setFont(font);\r\n        g2d.setColor(Color.darkGray);\r\n\r\n        g2d.drawString(\"Ammo: \" + ammo + \"/\" + maxAmmo, 10, 50);\r\n        g2d.drawString(\"RUNAWAY: \" + runawayDucks, 10, 21);\r\n        g2d.drawString(\"KILLS: \" + killedDucks, 160, 21);\r\n        g2d.drawString(\"SHOOTS: \" + shoots, 299, 21);\r\n        g2d.drawString(\"SCORE: \" + score, 440, 21);\r\n        g2d.drawString(\"Round: \" + Round, 570, 21);\r\n        g2d.drawString(\"Money: \" + money, 700, 21);\r\n        g2d.drawString(\"PlayerHP: \" + PlayerHp, 10, 80);\r\n    }\r\n\r\n    /**\r\n     * Draw the game over screen.\r\n     *\r\n     * @param g2d Graphics2D\r\n     * @param mousePosition Current mouse position.\r\n     */\r\n    public void DrawGameOver(Graphics2D g2d, Point mousePosition)\r\n    {\r\n        Draw(g2d, mousePosition);\r\n        g2d.drawImage(gameoverImg, 0,0,Framework.frameWidth,Framework.frameHeight, null);\r\n        g2d.drawImage(gameoverfImg, Framework.frameWidth/2,Framework.frameHeight/2,400,400, null);\r\n    }\r\n    public void DrawEnding(Graphics2D g2d, Point mousePosition, long gameTime) {\r\n        // 배경화면 설정 (엔딩 전용 배경 이미지)\r\n        g2d.drawImage(endingImages[ed], 0, 0, Framework.frameWidth-50, Framework.frameHeight-50, null);\r\n    }\r\n    public void NextEnding(){\r\n        ed++;\r\n    }\r\n\r\n    public int getScore(){\r\n        return score;\r\n    }\r\n\r\n    public void setgun(String gun){\r\n        this.gun = gun;\r\n    }\r\n\r\n    private void Reload() {\r\n        isReloading = true;\r\n        playActiveSound(\"src/main/resources/sounds/reloading.wav\");\r\n        reloadStartTime = System.nanoTime();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/kr/jbnu/se/std/Game.java b/src/main/java/kr/jbnu/se/std/Game.java
--- a/src/main/java/kr/jbnu/se/std/Game.java	(revision 33e22c7faa58025ae72751ac42af09608d48e8bf)
+++ b/src/main/java/kr/jbnu/se/std/Game.java	(date 1733065597498)
@@ -199,7 +199,7 @@
 
                 playBackgroundMusic("src/main/resources/sounds/MoonlightShadow.wav");
 
-                updateGameState(Framework.GameState.PLAYING);
+                Framework.gameState = Framework.GameState.PLAYING;
             }
         };
         threadForInitGame.start();
@@ -442,6 +442,8 @@
 
 
     private void updateFireSelectedDucks() {
+        Random random = new Random();
+
         for (int i = 0; i < FireSelectedDucks.length; i++) {
             if (hunterSelectedDucks[i] == null || !ducks.contains(hunterSelectedDucks[i]) || !ducks.contains(playerSelectedDucks[i])) {
                 // 새로운 오리를 선택하여 중복되지 않게 추가
@@ -547,8 +549,6 @@
         }
     }
 
-
-
     // 더블배럴샷건 모드에서 Hunter 선택된 오리들에게 sightImg를 그리기
     private void drawSightOnHunterSelectedDucks(Graphics2D g2d) {
         if (hunterSelectedDucks != null) {
@@ -597,19 +597,16 @@
         ducks.clear();
         isPause = true;
         System.out.println("buttonbuyadd");
-        Framework.setGameState(Framework.GameState.PAUSE);
+        Framework.gameState = Framework.GameState.PAUSE;
         stopBackgroundMusic();
     }
 
-    public enum GameState {
-        PAUSE, PLAYING, GAME_OVER, MAIN_MENU;
-    }
 
     public void NextRound() {
         stopBackgroundMusic();
         isPause = false;
-        Framework.setGameState(Framework.GameState.PLAYING);
-        //Duck.lastDuckTime = 0; // 오리 타이머 초기화
+        Framework.gameState = Framework.GameState.PLAYING;
+        Duck.lastDuckTime = 0; // 오리 타이머 초기화
         killedDucks = 0; // 죽인 오리 수 초기화
         runawayDucks = 0; // 도망간 오리 수 초기화
         Round += 1;
@@ -1019,12 +1016,12 @@
             hunterTrigger = false;
         }else if(!Hunter1){
         }else if(!hunterTrigger){
-
         }
+
         if(!isPause) {
             int maxGiftBoxes = 1;
             int Random = 1+(int)(Math.random()*1000);
-            // Creates a new duck, if it's the time, and add it to the array list.
+        // Creates a new duck, if it's the time, and add it to the array list.
             // 랜덤한 간격으로 선물 상자를 생성
             if (System.nanoTime() - lastGiftBoxTime >= giftBoxInterval * 1_000_000) {
                 if ((giftBoxes.size() < maxGiftBoxes) && Random == 50) {
@@ -1067,8 +1064,8 @@
                         fire = true;
                         ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
                         scheduler.schedule(() -> {
-                            stopFireAutoKill();
-                            fire = false;
+                           stopFireAutoKill();
+                           fire = false;
                         }, 9000, TimeUnit.SECONDS);// 3초 후 실행/ 1번 상자: 돈 증가
                     } else if (giftBoxes.get(i).type == 2) {
                         // 모든 오리의 속도를 증가시키기
@@ -1109,148 +1106,148 @@
 
             if (System.nanoTime() - Duck.lastDuckTime >= Duck.timeBetweenDucks) {
 
-                if (isReloading) {
-                    if (System.nanoTime() - reloadStartTime >= reloadDuration) {
-                        ammo = maxAmmo;   // 탄약을 최대치로 채움
-                        isReloading = false; // 장전 상태 해제
-                    }
-                }
-                if(ammo<=0 && !isReloading){
-                    Reload();
-                }
+            if (isReloading) {
+                if (System.nanoTime() - reloadStartTime >= reloadDuration) {
+                    ammo = maxAmmo;   // 탄약을 최대치로 채움
+                    isReloading = false; // 장전 상태 해제
+                }
+            }
+            if(ammo<=0 && !isReloading){
+                Reload();
+            }
 
-                if (framework.getGun().equals("더블배럴샷건")) {
-                    selectPlayerDucks(1);
-                    // 선택된 오리들이 죽었는지 확인하고, 죽으면 다시 선택
-                }else if(framework.getGun().equals("기본권총")){
+            if (framework.getGun().equals("더블배럴샷건")) {
+                selectPlayerDucks(1);
+                // 선택된 오리들이 죽었는지 확인하고, 죽으면 다시 선택
+            }else if(framework.getGun().equals("기본권총")){
 
-                }
-                // Here we create new duck and add it to the array list.
-                ducks.add(new Duck(Duck.duckLines[Duck.nextDuckLines][0] + random.nextInt(200), Duck.duckLines[Duck.nextDuckLines][1], Duck.duckLines[Duck.nextDuckLines][2], Duck.duckLines[Duck.nextDuckLines][3],duckImg));
+            }
+            // Here we create new duck and add it to the array list.
+            ducks.add(new Duck(Duck.duckLines[Duck.nextDuckLines][0] + random.nextInt(200), Duck.duckLines[Duck.nextDuckLines][1], Duck.duckLines[Duck.nextDuckLines][2], Duck.duckLines[Duck.nextDuckLines][3],duckImg));
 
-                // Here we increase nextDuckLines so that next duck will be created in next line.
-                Duck.incrementNextDuckLines();
-                if (Duck.nextDuckLines >= Duck.duckLines.length)
-                    Duck.resetNextDuckLines();
+            // Here we increase nextDuckLines so that next duck will be created in next line.
+            Duck.incrementNextDuckLines();
+            if (Duck.nextDuckLines >= Duck.duckLines.length)
+                Duck.resetNextDuckLines();
 
-                if (killedDucks >= roundPass && !isBossAlive) {
-                    // 보스 생성
-                    stopBackgroundMusic();
-                    playBackgroundMusic("src/main/resources/sounds/warning.wav");
-                    spawnBossWithDelay();
-                    Bosswith3delay = true;
-                    isBossAlive = true; // 보스가 등장했음을 표시
-                    System.out.println("boss activity");
-                    endingStartTime = System.nanoTime();
-                    ducks.clear();
-                }
-                Duck.setLastDuckTime(System.nanoTime());
-            }
+            if (killedDucks >= roundPass && !isBossAlive) {
+                // 보스 생성
+                stopBackgroundMusic();
+                playBackgroundMusic("src/main/resources/sounds/warning.wav");
+                spawnBossWithDelay();
+                Bosswith3delay = true;
+                isBossAlive = true; // 보스가 등장했음을 표시
+                System.out.println("boss activity");
+                endingStartTime = System.nanoTime();
+                ducks.clear();
+            }
+            Duck.setLastDuckTime(System.nanoTime());
+        }
 
-            if(!isBossAlive) {
-                // Update all of the ducks.
-                for (int i = 0; i < ducks.size(); i++) {
-                    // Move the duck.
-                    ducks.get(i).Update();
+        if(!isBossAlive) {
+            // Update all of the ducks.
+            for (int i = 0; i < ducks.size(); i++) {
+                // Move the duck.
+                ducks.get(i).Update();
 
-                    // Checks if the duck leaves the screen and remove it if it does.
-                    if (ducks.get(i).x < 0 - duckImg.getWidth()) {
-                        ducks.remove(i);
-                        runawayDucks++;
-                    }
-                }
-                // Does player shoots?
-                if (Canvas.mouseButtonState(MouseEvent.BUTTON1) && !isReloading) {
-                    if (System.nanoTime() - lastTimeShoot >= timeBetweenShots) {
-                        shoots++;
-                        playActiveSound("src/main/resources/sounds/gun.wav");
-                        ammo--;
-                        if (playerSelectedDucks != null) {
-                            for (int i = 0; i < playerSelectedDucks.length; i++) {
-                                if (playerSelectedDucks[i] != null) {
-                                    playActiveSound("src/main/resources/sounds/quack.wav");
-                                    killedDucks++; // 죽인 오리 수 증가
-                                    money += 10; // 돈 증가
-                                    score += playerSelectedDucks[i].score; // 점수 증가
-                                    // 오리 리스트에서 제거
-                                    ducks.remove(playerSelectedDucks[i]);
+                // Checks if the duck leaves the screen and remove it if it does.
+                if (ducks.get(i).x < 0 - duckImg.getWidth()) {
+                    ducks.remove(i);
+                    runawayDucks++;
+                }
+            }
+            // Does player shoots?
+            if (Canvas.mouseButtonState(MouseEvent.BUTTON1) && !isReloading) {
+                if (System.nanoTime() - lastTimeShoot >= timeBetweenShots) {
+                    shoots++;
+                    playActiveSound("src/main/resources/sounds/gun.wav");
+                    ammo--;
+                    if (playerSelectedDucks != null) {
+                        for (int i = 0; i < playerSelectedDucks.length; i++) {
+                            if (playerSelectedDucks[i] != null) {
+                                playActiveSound("src/main/resources/sounds/quack.wav");
+                                killedDucks++; // 죽인 오리 수 증가
+                                money += 10; // 돈 증가
+                                score += playerSelectedDucks[i].score; // 점수 증가
+                                // 오리 리스트에서 제거
+                                ducks.remove(playerSelectedDucks[i]);
 
-                                    // 선택된 오리를 null로 설정하여 초기화
-                                    playerSelectedDucks[i] = null;
-                                    updateAndReselectPlayerDucks(1);
-                                }
-                            }
-                        }
-                        // We go over all the ducks and we look if any of them was shoot.
-                        for (int i = 0; i < ducks.size(); i++) {
-                            // We check, if the mouse was over ducks head or body, when player has shot.
-                            if (new Rectangle(ducks.get(i).x + 18, ducks.get(i).y, 27, 30).contains(mousePosition) ||
-                                    new Rectangle(ducks.get(i).x + 30, ducks.get(i).y + 30, 88, 25).contains(mousePosition)) {
-                                killedDucks++;
-                                money += 10;
-                                score += ducks.get(i).score;
-                                playActiveSound("src/main/resources/sounds/quack.wav");
+                                // 선택된 오리를 null로 설정하여 초기화
+                                playerSelectedDucks[i] = null;
+                                updateAndReselectPlayerDucks(1);
+                            }
+                        }
+                    }
+                    // We go over all the ducks and we look if any of them was shoot.
+                    for (int i = 0; i < ducks.size(); i++) {
+                        // We check, if the mouse was over ducks head or body, when player has shot.
+                        if (new Rectangle(ducks.get(i).x + 18, ducks.get(i).y, 27, 30).contains(mousePosition) ||
+                                new Rectangle(ducks.get(i).x + 30, ducks.get(i).y + 30, 88, 25).contains(mousePosition)) {
+                            killedDucks++;
+                            money += 10;
+                            score += ducks.get(i).score;
+                            playActiveSound("src/main/resources/sounds/quack.wav");
 
-                                // Remove the duck from the array list.
-                                ducks.remove(i);
+                            // Remove the duck from the array list.
+                            ducks.remove(i);
 
-                                // We found the duck that player shoot so we can leave the for loop.
-                                break;
-                            }
-                        }
-                        // We go over all the bosses and we look if any of them was shoot.
-                        // We go over all the bosses and we look if any of them was shoot.
+                            // We found the duck that player shoot so we can leave the for loop.
+                            break;
+                        }
+                    }
+                    // We go over all the bosses and we look if any of them was shoot.
+                    // We go over all the bosses and we look if any of them was shoot.
 
 
-                        lastTimeShoot = System.nanoTime();
-                    }
-                }
-            }else {
+                    lastTimeShoot = System.nanoTime();
+                }
+            }
+        }else {
 
-                if (Canvas.mouseButtonState(MouseEvent.BUTTON1) && !isReloading) {
-                    if (System.nanoTime() - lastTimeShoot >= timeBetweenShots) {
-                        shoots++;
-                        ammo--;
-                        if (isBossAlive) {
-                            for (int i = 0; i < boss.size(); i++) {
-                                // Define the boss hitbox (for exampl, a larger area for the boss).
-                                // 보스가 랜덤 각도로 공격 발사
-                                if (new Rectangle(boss.get(i).x, boss.get(i).y, 378, 268).contains(mousePosition)) {
-                                    // Reduce boss health
-                                    playActiveSound("src/main/resources/sounds/gun.wav");
-                                    boss.get(i).health -= damage; // Reduce boss health by 20 on each hit.
-                                    System.out.println("attack boss");
-                                    System.out.println(boss.get(i).health);
-                                    // If the boss is dead, update score, money, etc.
-                                    if (boss.get(i).health <= 0) {
-                                        money += 100; // Bosses give more money
-                                        score += boss.get(i).score; // Boss-specific score
-                                        boss.remove(i);
-                                        if (Round == 5) {
-                                            Framework.GameState currentState = Framework.getGameState();
-                                            stopBackgroundMusic();
-                                            endingStartTime = System.currentTimeMillis();
-                                            framework.saveScore(score);
-                                            framework.saveScore(score);
-                                            leaderboardSaved = true;
-                                            playBackgroundMusic("src/main/resources/sounds/NewBeginningNotTheEnd.wav"); // 엔딩 테마곡 재생
-                                        } else {
-                                            Pause(); // 다른 라운드의 경우 일시 정지 상태로 전환
-                                        }
-                                    }
-                                    break;
-                                    // Since a boss was hit, we can leave the loop.
-                                }
-                            }
-                        }
-                    }
-                    lastTimeShoot = System.nanoTime();
-                }
-            }
+            if (Canvas.mouseButtonState(MouseEvent.BUTTON1) && !isReloading) {
+                if (System.nanoTime() - lastTimeShoot >= timeBetweenShots) {
+                    shoots++;
+                    ammo--;
+                    if (isBossAlive) {
+                        for (int i = 0; i < boss.size(); i++) {
+                            // Define the boss hitbox (for exampl, a larger area for the boss).
+                            // 보스가 랜덤 각도로 공격 발사
+                            if (new Rectangle(boss.get(i).x, boss.get(i).y, 378, 268).contains(mousePosition)) {
+                                // Reduce boss health
+                                playActiveSound("src/main/resources/sounds/gun.wav");
+                                boss.get(i).health -= damage; // Reduce boss health by 20 on each hit.
+                                System.out.println("attack boss");
+                                System.out.println(boss.get(i).health);
+                                // If the boss is dead, update score, money, etc.
+                                if (boss.get(i).health <= 0) {
+                                    money += 100; // Bosses give more money
+                                    score += boss.get(i).score; // Boss-specific score
+                                    boss.remove(i);
+                                    if (Round == 5) {
+                                        Framework.gameState = Framework.GameState.ENDING;
+                                        stopBackgroundMusic();
+                                        endingStartTime = System.currentTimeMillis();
+                                        framework.saveScore(score);
+                                        framework.saveScore(score);
+                                        leaderboardSaved = true;
+                                        playBackgroundMusic("src/main/resources/sounds/NewBeginningNotTheEnd.wav"); // 엔딩 테마곡 재생
+                                    } else {
+                                        Pause(); // 다른 라운드의 경우 일시 정지 상태로 전환
+                                    }
+                                }
+                                break;
+                                // Since a boss was hit, we can leave the loop.
+                            }
+                        }
+                    }
+                }
+                lastTimeShoot = System.nanoTime();
+            }
+        }
 
-            // When 200 ducks runaway, the game ends.
+        // When 200 ducks runaway, the game ends.
             if (runawayDucks >= 10 || PlayerHp < 0 )
-                Framework.setGameState(Framework.GameState.GAMEOVER);
+                Framework.gameState = Framework.GameState.GAMEOVER;
             if (Framework.gameState == Framework.GameState.GAMEOVER && !leaderboardSaved) {
                 framework.saveScore(score);
                 framework.saveMoney(score);
@@ -1311,7 +1308,7 @@
         if(Hunters.size() > 0) {
             Hunter1 = true;
         }
-    }
+}
 
     public void drawBossAttack(Graphics2D g2d){
         for(int i = 0; i < bossAttacks.size(); i++) {
@@ -1358,167 +1355,151 @@
      * @param g2d Graphics2D
      * @param mousePosition current mouse position.
      */
+    public void Draw(Graphics2D g2d, Point mousePosition)
+    {
+        if (Round == 1){
+            g2d.drawImage(backgroundImg, 0, 0, Framework.frameWidth, Framework.frameHeight, null);
+        }
+
+        if(Round == 2){
+            g2d.drawImage(backgroundImg2, 0, 0, Framework.frameWidth, Framework.frameHeight, null);
+        }
 
-    public void Draw(Graphics2D g2d, Point mousePosition) {
-        drawBackground(g2d);
-        drawDucks(g2d);
-        drawBossWarning(g2d);
-        drawHunter1(g2d);
-        drawBossAttacks(g2d);
-        drawBoss(g2d);
-        drawButtonsAndShop(g2d);
-        drawGiftBoxes(g2d);
-        configureGunSettings(g2d);
-        drawGunSightAndReloadStatus(g2d, mousePosition);
-        drawHUD(g2d);
-    }
+        if(Round == 3){
+            g2d.drawImage(backgroundImg3, 0, 0, Framework.frameWidth, Framework.frameHeight, null);
+        }
 
-    // 배경 그리기
-    private void drawBackground(Graphics2D g2d) {
-        Image[] backgrounds = { backgroundImg, backgroundImg2, backgroundImg3, backgroundImg4, backgroundImg5 };
-        if (Round >= 1 && Round <= 5) {
-            g2d.drawImage(backgrounds[Round - 1], 0, 0, Framework.frameWidth, Framework.frameHeight, null);
+        if(Round == 4){
+            g2d.drawImage(backgroundImg4, 0, 0, Framework.frameWidth, Framework.frameHeight, null);
         }
-    }
+
+        if(Round == 5){
+            g2d.drawImage(backgroundImg5, 0, 0, Framework.frameWidth, Framework.frameHeight, null);
+        }
 
-    // 모든 오리 그리기
-    private void drawDucks(Graphics2D g2d) {
-        for (int i = 0; i < ducks.size(); i++) {
+        // Here we draw all the ducks.
+        for(int i = 0; i < ducks.size(); i++)
+        {
             ducks.get(i).Draw(g2d);
         }
-    }
-
-    // 보스 공격 경고 그리기
-    private void drawBossWarning(Graphics2D g2d) {
-        if (Bosswith3delay) {
-            g2d.drawImage(warningImg, Framework.frameWidth / 2 - 275, Framework.frameHeight / 2 - 250, null);
+        if(Bosswith3delay){
+            g2d.drawImage(warningImg,Framework.frameWidth/2-275,Framework.frameHeight/2-250, null);
         }
-    }
-
-    // 헌터1 그리기 및 관련 처리
-    private void drawHunter1(Graphics2D g2d) {
-        if (Hunter1) {
-            g2d.drawImage(hunter111Img, Hunters.get(0).x, Hunters.get(0).y, null);
+        if(Hunter1){
+            g2d.drawImage(hunter111Img,Hunters.get(0).x,Hunters.get(0).y,null);
             drawSightOnHunterSelectedDucks(g2d);
+
         }
-    }
+
+        if(bossAttacks.size() > 0){
+            for(int i = 0; i < bossAttacks.size(); i++) {
+                g2d.drawImage(bossAttack, bossAttacks.get(i).x,bossAttacks.get(i).y, null );
+            }
+        }
 
-    // 보스 공격 처리 (보스 공격 목록 및 이미지 그리기)
-    private void drawBossAttacks(Graphics2D g2d) {
-        List<List<BossAttack>> bossAttackLists = Arrays.asList(bossAttacks, bossAttacks2, bossAttacks3, bossAttacks4, bossAttacks5);
-        List<Image> bossAttackImages = Arrays.asList(bossAttack, bossAttack2, bossAttack3, bossAttack4, bossAttack5);
+        if(bossAttacks2.size() >0){
+            for(int i = 0; i < bossAttacks2.size(); i++) {
+                g2d.drawImage(bossAttack2, bossAttacks2.get(i).x,bossAttacks2.get(i).y,100,100,null);
+            }
+        }
 
-        for (int i = 0; i < bossAttackLists.size(); i++) {
-            List<BossAttack> currentList = bossAttackLists.get(i);
-            Image currentImage = bossAttackImages.get(i);
+        if(bossAttacks3.size() > 0){
+            for(int i = 0; i < bossAttacks3.size(); i++) {
+                g2d.drawImage(bossAttack3, bossAttacks3.get(i).x,bossAttacks3.get(i).y,100,100,null);
+            }
+        }
 
-            if (currentList.size() > 0) {
-                for (BossAttack attack : currentList) {
-                    g2d.drawImage(currentImage, attack.x, attack.y, 100, 100, null);
-                }
-            }
-        }
-    }
+        if(bossAttacks4.size() > 0){
+            for(int i = 0; i < bossAttacks4.size(); i++) {
+                g2d.drawImage(bossAttack4, bossAttacks4.get(i).x,bossAttacks4.get(i).y,100,100,null);
+            }
+        }
+
+        if(bossAttacks5.size() > 0){
+            for(int i = 0; i < bossAttacks5.size(); i++) {
+                g2d.drawImage(bossAttack5, bossAttacks5.get(i).x,bossAttacks5.get(i).y,100,100,null);
+            }
+        }
 
-    // 보스 그리기 및 HP 바 그리기
-    private void drawBoss(Graphics2D g2d) {
+        if(isPause){
+            int buyWidth = buttonImg.getWidth(null) / 2; // 너비 50%
+            int buyHeight = buttonImg.getHeight(null) / 2; // 높이 50%
+            for(int i = 0; i < buttonbuy.size(); i++) {
+                g2d.drawImage(buttonImg, buttonbuy.get(i).x, buttonbuy.get(i).y,buyWidth,buyHeight,null);
+            }
+            for(int i = 0; i < shopImages.length; i++) {
+                g2d.drawImage(shopImages[i],buttonbuy.get(i).x-60, buttonbuy.get(i).y - 250, 300,300,null);
+            }
+        }
+        // 보스 그리기
         if (!boss.isEmpty()) {
             for (int i = 0; i < boss.size(); i++) {
-                BufferedImage bossImage = getBossImageForRound();
-                if (bossImage != null) {
-                    g2d.drawImage(bossImage, boss.get(i).x - 90, boss.get(i).y - 20, 378, 268, null);
+                // 보스 이미지 그리기
+                if(Round == 1) {
+                    g2d.drawImage(bossImg, boss.get(i).x - 90, boss.get(i).y - 20, 378/2, 268/2, null);
+                }else if(Round == 2) {
+                    g2d.drawImage(boss2Img, boss.get(i).x - 90, boss.get(i).y - 20, 378, 268, null);
+                }else if(Round == 3) {
+                    g2d.drawImage(boss3Img, boss.get(i).x - 90, boss.get(i).y - 20, 378, 268, null);
+                }else if(Round == 4) {
+                    g2d.drawImage(boss4Img, boss.get(i).x - 90, boss.get(i).y - 20, 378, 268, null);
+                }else if(Round == 5){
+                    g2d.drawImage(boss5Img, boss.get(i).x - 90, boss.get(i).y - 20, 378, 268, null);
                 }
-
-                drawBossHealthBar(g2d, i);
-            }
-        }
-    }
-
-    private BufferedImage getBossImageForRound() {
-        switch (Round) {
-            case 1: return bossImg;
-            case 2: return boss2Img;
-            case 3: return boss3Img;
-            case 4: return boss4Img;
-            case 5: return boss5Img;
-            default: System.err.println("Warning: Unexpected gift box type: " + Round); return null;
-        }
-    }
-
-    private void drawBossHealthBar(Graphics2D g2d, int i) {
-        int currentHealth = boss.get(i).health;
-        int maxHealth = boss.get(i).maxHealth;
-        int hpIndex = (int) ((currentHealth / (double) maxHealth) * 11);
-        hpIndex = Math.max(0, Math.min(11, hpIndex));
+                // 보스의 체력 상태를 기반으로 HP 이미지를 선택
+                int currentHealth = boss.get(i).health;
+                int maxHealth = boss.get(i).maxHealth; // 보스의 최대 체력
 
-        int hpBarWidth = hpImages[hpIndex].getWidth(null) / 8;
-        int hpBarHeight = hpImages[hpIndex].getHeight(null) / 8;
-        g2d.drawImage(hpImages[hpIndex], boss.get(i).x - 20, boss.get(i).y - 60, hpBarWidth, hpBarHeight, null);
-    }
-
-    // 버튼과 상점 그리기
-    private void drawButtonsAndShop(Graphics2D g2d) {
-        if (isPause) {
-            int buyWidth = buttonImg.getWidth(null) / 2;
-            int buyHeight = buttonImg.getHeight(null) / 2;
-            for (int i = 0; i < buttonbuy.size(); i++) {
-                g2d.drawImage(buttonImg, buttonbuy.get(i).x, buttonbuy.get(i).y, buyWidth, buyHeight, null);
-                if (i < shopImages.length) {
-                    g2d.drawImage(shopImages[i], buttonbuy.get(i).x - 60, buttonbuy.get(i).y - 250, 300, 300, null);
-                }
+                // 체력에 따른 HP 이미지를 표시
+                int hpIndex = (int) ((currentHealth / (double) maxHealth) * 11); // 0에서 11까지의 인덱스를 계산
+                hpIndex = Math.max(0, Math.min(11, hpIndex)); // 범위를 0 ~ 11로 제한
+                // HP 바 크기 조정 (예: 50% 크기)
+                int hpBarWidth = hpImages[hpIndex].getWidth(null) / 8; // 너비 50%
+                int hpBarHeight = hpImages[hpIndex].getHeight(null) / 8; // 높이 50%
+
+                // HP 바 그리기 (크기 조정 후)
+                g2d.drawImage(hpImages[hpIndex], boss.get(i).x - 20, boss.get(i).y - 60, hpBarWidth, hpBarHeight, null);
             }
         }
-    }
-
-    // 선물 상자 그리기
-    private void drawGiftBoxes(Graphics2D g2d) {
-        if (giftBoxes != null) {
-            for (GiftBox giftBox : giftBoxes) {
-                BufferedImage selectedImg = getGiftBoxImage(giftBox.type);
-                if (selectedImg != null) {
-                    g2d.drawImage(selectedImg, giftBox.x, giftBox.y, giftBox.width, giftBox.height, null);
-                }
-            }
+        if(fire){
+            drawSightOnFireSelectedDucks(g2d);
+        }
+        if(isReloading){
+            g2d.drawString("Reloading", Framework.frameWidth/2, Framework.frameHeight/2);
         }
-    }
 
-    private BufferedImage getGiftBoxImage(int type) {
-        switch (type) {
-            case 1: return giftBoxImg1;
-            case 2: return giftBoxImg2;
-            case 3: return giftBoxImg3;
-            default:
-                System.err.println("Warning: Unexpected gift box type: " + type);
-                return null;
-        }
-    }
-
-    // 총기 설정
-    private void configureGunSettings(Graphics2D g2d) {
+        g2d.drawImage(sightImg, mousePosition.x - sightImgMiddleWidth, mousePosition.y - sightImgMiddleHeight, null);
+        // 더블배럴샷건일 때 랜덤 오리 2마리 지정
         if (framework.getGun().equals("더블배럴샷건")) {
             drawSightOnPlayerSelectedDucks(g2d);
             reloadDuration = 2500000000L;
-        } else if (framework.getGun().equals("AK-47")) {
+        }
+        if(framework.getGun().equals("AK-47")){
             maxAmmo = 30;
             reloadDuration = 3000000000L;
             timeBetweenShots = 100_000_000L;
         }
-    }
+
+        if(giftBoxes != null){
+            for (GiftBox giftBox : giftBoxes) {
+                // 타입에 맞는 이미지를 그리도록 설정
+                BufferedImage selectedImg = null;
+                if (giftBox.type == 1) {
+                    selectedImg = giftBoxImg1;
+                } else if (giftBox.type == 2) {
+                    selectedImg = giftBoxImg2;
+                } else if (giftBox.type == 3) {
+                    selectedImg = giftBoxImg3;
+                }
 
-    // 총기 조준선과 리로드 상태 그리기
-    private void drawGunSightAndReloadStatus(Graphics2D g2d, Point mousePosition) {
-        if (fire) {
-            drawSightOnFireSelectedDucks(g2d);
-        }
-        if (isReloading) {
-            g2d.drawString("Reloading", Framework.frameWidth / 2, Framework.frameHeight / 2);
+                // 이미지가 null이 아닐 때만 그리기
+                if (selectedImg != null) {
+                    g2d.drawImage(selectedImg, giftBox.x, giftBox.y, giftBox.width, giftBox.height, null);
+                }
+            }
         }
 
-        g2d.drawImage(sightImg, mousePosition.x - sightImgMiddleWidth, mousePosition.y - sightImgMiddleHeight, null);
-    }
 
-    // HUD (Heads-Up Display) 그리기
-    private void drawHUD(Graphics2D g2d) {
         g2d.setFont(font);
         g2d.setColor(Color.darkGray);
 
@@ -1529,8 +1510,11 @@
         g2d.drawString("SCORE: " + score, 440, 21);
         g2d.drawString("Round: " + Round, 570, 21);
         g2d.drawString("Money: " + money, 700, 21);
+
         g2d.drawString("PlayerHP: " + PlayerHp, 10, 80);
+
     }
+
 
     /**
      * Draw the game over screen.
@@ -1546,7 +1530,7 @@
     }
     public void DrawEnding(Graphics2D g2d, Point mousePosition, long gameTime) {
         // 배경화면 설정 (엔딩 전용 배경 이미지)
-        g2d.drawImage(endingImages[ed], 0, 0, Framework.frameWidth-50, Framework.frameHeight-50, null);
+            g2d.drawImage(endingImages[ed], 0, 0, Framework.frameWidth-50, Framework.frameHeight-50, null);
     }
     public void NextEnding(){
         ed++;
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"e255d515-7351-4cf8-8843-af8a77729b48\" name=\"Changes\" comment=\"문자열 리터럴 중복 =&gt; 상수로 대체\">\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Duck.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Duck.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Game.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Game.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"backup\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;kimjaehoug&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/kimjaehoug/wherelouisjeon.git&quot;,\r\n    &quot;accountId&quot;: &quot;fbb2cdd8-8f11-4e46-b870-8e948249df1a&quot;\r\n  }\r\n}</component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 5\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2l32qehEPZRF5c71kAtLRu0eskA\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Application.MainClient.executor\": \"Run\",\r\n    \"Application.MainV2.executor\": \"Run\",\r\n    \"Application.ShopWindow.executor\": \"Run\",\r\n    \"Application.Window (1).executor\": \"Run\",\r\n    \"Application.Window.executor\": \"Run\",\r\n    \"Application.Window2222.executor\": \"Run\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"SHARE_PROJECT_CONFIGURATION_FILES\": \"true\",\r\n    \"SONARLINT_PRECOMMIT_ANALYSIS\": \"true\",\r\n    \"WebServerToolWindowFactoryState\": \"false\",\r\n    \"git-widget-placeholder\": \"backup__gu\",\r\n    \"kotlin-language-version-configured\": \"true\",\r\n    \"last_opened_file_path\": \"/Users/jae/Downloads/shoottheduck\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"project.structure.last.edited\": \"Modules\",\r\n    \"project.structure.proportion\": \"0.15\",\r\n    \"project.structure.side.proportion\": \"0.2\",\r\n    \"settings.editor.selected.configurable\": \"profiler.calltree.filter\",\r\n    \"vue.rearranger.settings.migration\": \"true\",\r\n    \"애플리케이션.Window.executor\": \"Run\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"D:\\70.Classes\\2024-2\\source_code_analysis\\shoottheduck\\src\\main\\resources\" />\r\n      <recent name=\"D:\\70.Classes\\2024-2\\source_code_analysis\\shoottheduck\\src\\main\\java\" />\r\n    </key>\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"$PROJECT_DIR$/src/main\" />\r\n      <recent name=\"$PROJECT_DIR$/src/main/resources/images\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"애플리케이션.Window\">\r\n    <configuration name=\"MainClient\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"kr.jbnu.se.std.MainClient\" />\r\n      <module name=\"shoottheduck\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"kr.jbnu.se.std.MultiPlayer.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"MainV2\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"kr.jbnu.se.std.MainV2\" />\r\n      <module name=\"shoottheduck\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"kr.jbnu.se.std.MultiPlayer.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"ShopWindow\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"kr.jbnu.se.std.ShopWindow\" />\r\n      <module name=\"shoottheduck\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"kr.jbnu.se.std.MultiPlayer.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Window\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"kr.jbnu.se.std.Window\" />\r\n      <module name=\"shoottheduck\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Window2222\" type=\"Application\" factoryName=\"Application\" temporary=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"kr.jbnu.se.std.Window\" />\r\n      <module name=\"shoottheduck\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"kr.jbnu.se.std.MultiPlayer.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"애플리케이션.MainClient\" />\r\n      <item itemvalue=\"애플리케이션.MainV2\" />\r\n      <item itemvalue=\"애플리케이션.ShopWindow\" />\r\n      <item itemvalue=\"애플리케이션.Window\" />\r\n      <item itemvalue=\"애플리케이션.Window2222\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"애플리케이션.Window\" />\r\n        <item itemvalue=\"애플리케이션.Window2222\" />\r\n        <item itemvalue=\"애플리케이션.ShopWindow\" />\r\n        <item itemvalue=\"애플리케이션.MainV2\" />\r\n        <item itemvalue=\"애플리케이션.MainClient\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-jdk-9823dce3aa75-28b599e66164-intellij.indexing.shared.core-IU-242.23339.11\" />\r\n        <option value=\"bundled-js-predefined-d6986cc7102b-5c90d61e3bab-JavaScript-IU-242.23339.11\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"e255d515-7351-4cf8-8843-af8a77729b48\" name=\"Changes\" comment=\"\" />\r\n      <created>1724394633914</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1724394633914</updated>\r\n      <workItem from=\"1724394635024\" duration=\"2830000\" />\r\n      <workItem from=\"1724829453673\" duration=\"684000\" />\r\n      <workItem from=\"1725429507492\" duration=\"630000\" />\r\n      <workItem from=\"1726030595579\" duration=\"691000\" />\r\n      <workItem from=\"1726879738970\" duration=\"1652000\" />\r\n      <workItem from=\"1727238748652\" duration=\"1262000\" />\r\n      <workItem from=\"1727689816044\" duration=\"15230000\" />\r\n      <workItem from=\"1727776036881\" duration=\"31242000\" />\r\n      <workItem from=\"1727875707906\" duration=\"28902000\" />\r\n      <workItem from=\"1728066880239\" duration=\"8135000\" />\r\n      <workItem from=\"1732689810339\" duration=\"4764000\" />\r\n      <workItem from=\"1732722999734\" duration=\"23489000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"loginfunction\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727763605144</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727763605144</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"loginfunction\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727771161342</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727771161342</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"loginfunction\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727781698478</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727781698479</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"loginfunction\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727855380738</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727855380738</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"loginfunction\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727860170579</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727860170580</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727863174521</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727863174521</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727865267663</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727865267663</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727871541617</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727871541617</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727872888568</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727872888568</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1727872986113</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1727872986113</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1728031206772</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1728031206772</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1728031507710</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1728031507710</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1728277037261</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1728277037262</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00014\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1728277216143</created>\r\n      <option name=\"number\" value=\"00014\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1728277216143</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00015\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1728277380099</created>\r\n      <option name=\"number\" value=\"00015\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1728277380099</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00016\" summary=\"131313\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1728279465226</created>\r\n      <option name=\"number\" value=\"00016\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1728279465226</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00017\" summary=\"draw 메소드&#10;높은 인지 복잡성 문제 -&gt; 메소드 쪼개기\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1732937661946</created>\r\n      <option name=\"number\" value=\"00017\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1732937661946</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00018\" summary=\"selectPlayerDucks, selectHunterDucks,selectFireDucks, updateFireSelectedDucks, updateHunterSelectedDucks 메소드&#10;&#10;랜덤 객체 재사용 권장 =&gt; HashSet 사용하여 효율적인 중복 방지\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1732938907105</created>\r\n      <option name=\"number\" value=\"00018\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1732938907105</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00019\" summary=\"문자열 리터럴 중복 =&gt; 상수로 대체\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1732939841280</created>\r\n      <option name=\"number\" value=\"00019\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1732939841280</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"20\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"loginfunction\" />\r\n    <MESSAGE value=\"131313\" />\r\n    <MESSAGE value=\"yw\" />\r\n    <MESSAGE value=\"draw 메소드&#10;높은 인지 복잡성 문제 -&gt; 메소드 쪼개기\" />\r\n    <MESSAGE value=\"selectPlayerDucks, selectHunterDucks,selectFireDucks, updateFireSelectedDucks, updateHunterSelectedDucks 메소드&#10;&#10;랜덤 객체 재사용 권장 =&gt; HashSet 사용하여 효율적인 중복 방지\" />\r\n    <MESSAGE value=\"문자열 리터럴 중복 =&gt; 상수로 대체\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"문자열 리터럴 중복 =&gt; 상수로 대체\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 33e22c7faa58025ae72751ac42af09608d48e8bf)
+++ b/.idea/workspace.xml	(date 1733065598121)
@@ -4,9 +4,27 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="e255d515-7351-4cf8-8843-af8a77729b48" name="Changes" comment="문자열 리터럴 중복 =&gt; 상수로 대체">
-      <change beforePath="$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Duck.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Duck.java" afterDir="false" />
+    <list default="true" id="e255d515-7351-4cf8-8843-af8a77729b48" name="Changes" comment=".">
+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Framework.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Framework.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Game.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/kr/jbnu/se/std/Game.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$1.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$1.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$10.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$10.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$11.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$11.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$12.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$12.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$2.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$2.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$3.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$3.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$4.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$4.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$5.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$5.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$6.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$6.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$7.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$7.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$8.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$8.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$9.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework$9.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Framework.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Game$1.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Game$1.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Game$GameState.class" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Game.class" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/kr/jbnu/se/std/Game.class" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -23,7 +41,7 @@
   <component name="Git.Settings">
     <option name="RECENT_BRANCH_BY_REPOSITORY">
       <map>
-        <entry key="$PROJECT_DIR$" value="backup" />
+        <entry key="$PROJECT_DIR$" value="33e22c7faa58025ae72751ac42af09608d48e8bf" />
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
@@ -42,6 +60,9 @@
 }</component>
   <component name="MarkdownSettingsMigration">
     <option name="stateVersion" value="1" />
+  </component>
+  <component name="ProblemsViewState">
+    <option name="selectedTabId" value="CurrentFile" />
   </component>
   <component name="ProjectColorInfo">{
   &quot;associatedIndex&quot;: 5
@@ -76,6 +97,7 @@
     "project.structure.last.edited": "Modules",
     "project.structure.proportion": "0.15",
     "project.structure.side.proportion": "0.2",
+    "run.code.analysis.last.selected.profile": "pProject Default",
     "settings.editor.selected.configurable": "profiler.calltree.filter",
     "vue.rearranger.settings.migration": "true",
     "애플리케이션.Window.executor": "Run"
@@ -195,7 +217,8 @@
       <workItem from="1727875707906" duration="28902000" />
       <workItem from="1728066880239" duration="8135000" />
       <workItem from="1732689810339" duration="4764000" />
-      <workItem from="1732722999734" duration="23489000" />
+      <workItem from="1732722999734" duration="25383000" />
+      <workItem from="1733053416823" duration="10633000" />
     </task>
     <task id="LOCAL-00001" summary="loginfunction">
       <option name="closed" value="true" />
@@ -349,7 +372,31 @@
       <option name="project" value="LOCAL" />
       <updated>1732939841280</updated>
     </task>
-    <option name="localTasksCounter" value="20" />
+    <task id="LOCAL-00020" summary="정적 필드 문제 =&gt; 정적 필드를 업데이트 하는 부분을 동기화">
+      <option name="closed" value="true" />
+      <created>1732940327915</created>
+      <option name="number" value="00020" />
+      <option name="presentableId" value="LOCAL-00020" />
+      <option name="project" value="LOCAL" />
+      <updated>1732940327915</updated>
+    </task>
+    <task id="LOCAL-00021" summary="정적 필드 문제 =&gt; 정적 필드를 업데이트 하는 부분을 동기화">
+      <option name="closed" value="true" />
+      <created>1732940395978</created>
+      <option name="number" value="00021" />
+      <option name="presentableId" value="LOCAL-00021" />
+      <option name="project" value="LOCAL" />
+      <updated>1732940395978</updated>
+    </task>
+    <task id="LOCAL-00022" summary=".">
+      <option name="closed" value="true" />
+      <created>1732940547656</created>
+      <option name="number" value="00022" />
+      <option name="presentableId" value="LOCAL-00022" />
+      <option name="project" value="LOCAL" />
+      <updated>1732940547656</updated>
+    </task>
+    <option name="localTasksCounter" value="23" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -373,6 +420,8 @@
     <MESSAGE value="draw 메소드&#10;높은 인지 복잡성 문제 -&gt; 메소드 쪼개기" />
     <MESSAGE value="selectPlayerDucks, selectHunterDucks,selectFireDucks, updateFireSelectedDucks, updateHunterSelectedDucks 메소드&#10;&#10;랜덤 객체 재사용 권장 =&gt; HashSet 사용하여 효율적인 중복 방지" />
     <MESSAGE value="문자열 리터럴 중복 =&gt; 상수로 대체" />
-    <option name="LAST_COMMIT_MESSAGE" value="문자열 리터럴 중복 =&gt; 상수로 대체" />
+    <MESSAGE value="정적 필드 문제 =&gt; 정적 필드를 업데이트 하는 부분을 동기화" />
+    <MESSAGE value="." />
+    <option name="LAST_COMMIT_MESSAGE" value="." />
   </component>
 </project>
\ No newline at end of file
