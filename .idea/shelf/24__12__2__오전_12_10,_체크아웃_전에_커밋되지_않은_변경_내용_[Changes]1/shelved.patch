Index: src/main/java/kr/jbnu/se/std/MultiPlayer/MultiGame.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package kr.jbnu.se.std.MultiPlayer;\r\n\r\nimport kr.jbnu.se.std.*;\r\nimport kr.jbnu.se.std.Canvas;\r\n\r\nimport java.awt.*;\r\nimport java.awt.event.MouseEvent;\r\nimport java.awt.image.BufferedImage;\r\nimport java.io.IOException;\r\nimport java.net.URL;\r\nimport java.util.*;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport javax.imageio.ImageIO;\r\n\r\n/**\r\n * Actual game.\r\n *\r\n * @author www.gametutorial.net\r\n */\r\n\r\npublic class MultiGame {\r\n\r\n    /**\r\n     * We use this to generate a random number.\r\n     */\r\n    private Random random;\r\n    private boolean isPause = false;\r\n    private int Round;\r\n    private boolean isBossAlive;\r\n    private Duck[] hunterSelectedDucks;\r\n    private Duck[] playerSelectedDucks;\r\n    private int ammo;          // 현재 사용 가능한 총알\r\n    private int maxAmmo;       // 한 번에 장전할 수 있는 최대 탄약 수\r\n    private boolean isReloading; // 장전 중인지 여부\r\n    private long reloadStartTime; // 장전이 시작된 시간\r\n    private long reloadDuration;  // 장전 시간 (예: 2초)\r\n    private URL hpUrl;\r\n    private int selectduck;\r\n    private ScheduledExecutorService hunterExecutor;\r\n\r\n    /**\r\n     * Font that we will use to write statistic to the screen.\r\n     */\r\n    private Font font;\r\n    boolean hunterTrigger = true;\r\n\r\n    private BufferedImage bossImg;\r\n    private BufferedImage[] hpImages = new BufferedImage[12]; // HP 이미지를 저장할 배열\r\n\r\n    /**\r\n     * Array list of the ducks.\r\n     */\r\n    private ArrayList<Duck> ducks;\r\n    private ArrayList<boss1> boss;\r\n    private ArrayList<Buttonbuy> buttonbuy;\r\n    private ArrayList<kr.jbnu.se.std.Hunter1> Hunters;\r\n\r\n    /**\r\n     * How many ducks leave the screen alive?\r\n     */\r\n    private int runawayDucks;\r\n    private Framework framework;\r\n\r\n    /**\r\n     * How many ducks the player killed?\r\n     */\r\n    private int killedDucks;\r\n\r\n    /**\r\n     * For each killed duck, the player gets points.\r\n     */\r\n    private int score;\r\n    private int money;\r\n\r\n    /**\r\n     * How many times a player is shot?\r\n     */\r\n    private int shoots;\r\n    private boolean leaderboardSaved;\r\n    /**\r\n     * Last time of the shoot.\r\n     */\r\n    private long lastTimeShoot;\r\n    /**\r\n     * The time which must elapse between shots.\r\n     */\r\n    private long timeBetweenShots;\r\n\r\n    /**\r\n     * kr.jbnu.se.std.Game background image.\r\n     */\r\n    private BufferedImage backgroundImg;\r\n    private BufferedImage buttonImg;\r\n    private BufferedImage sightImg_hunter;\r\n\r\n    /**\r\n     * Bottom grass.\r\n     */\r\n    private BufferedImage grassImg;\r\n\r\n    /**\r\n     * kr.jbnu.se.std.Duck image.\r\n     */\r\n    private BufferedImage duckImg;\r\n\r\n    /**\r\n     * Shotgun sight image.\r\n     */\r\n    private BufferedImage sightImg;\r\n    private boolean Hunter1 = false;\r\n\r\n    /**\r\n     * Middle width of the sight image.\r\n     */\r\n    private int sightImgMiddleWidth;\r\n    /**\r\n     * Middle height of the sight image.\r\n     */\r\n    private int sightImgMiddleHeight;\r\n    private String gun;\r\n    private GameClient multiplayerClient;\r\n\r\n    private GameServer server;\r\n    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\r\n\r\n\r\n    public MultiGame(Framework framework, GameServer server) {\r\n        this.server = server;\r\n\r\n        Framework.gameState = Framework.GameState.GAME_CONTENT_LOADING;\r\n        this.framework = framework;\r\n        Thread threadForInitGame = new Thread() {\r\n            @Override\r\n            public void run() {\r\n                // Sets variables and objects for the game.\r\n                Initialize();\r\n                // Load game files (images, sounds, ...)\r\n                LoadContent();\r\n\r\n                Framework.gameState = Framework.GameState.PLAYING;\r\n            }\r\n        };\r\n        threadForInitGame.start();\r\n    }\r\n\r\n\r\n    /**\r\n     * Set variables and objects for the game.\r\n     */\r\n    private void Initialize() {\r\n        random = new Random();\r\n        font = new Font(\"monospaced\", Font.BOLD, 18);\r\n\r\n        ducks = new ArrayList<Duck>();\r\n        boss = new ArrayList<boss1>();\r\n        buttonbuy = new ArrayList<Buttonbuy>();\r\n        Hunters = new ArrayList<Hunter1>();\r\n\r\n        runawayDucks = 0;\r\n        killedDucks = 0;\r\n        score = 0;\r\n        shoots = 0;\r\n        Round = 1;\r\n        isBossAlive = false;\r\n        Hunter1 = false;\r\n        lastTimeShoot = 0;\r\n        timeBetweenShots = 500_000_000L;\r\n\r\n        ammo = 6;              // 기본 탄약 수\r\n        maxAmmo = 6;           // 최대 장전할 수 있는 탄약 수\r\n        isReloading = false;   // 초기에는 장전 중이 아님\r\n        reloadDuration = 2000000000L; // 장전 시간 2초 (나노초 단위)\r\n    }\r\n\r\n    /**\r\n     * Load game files - images, sounds, ...\r\n     */\r\n    private void LoadContent() {\r\n        try {\r\n            for (int i = 0; i < 12; i++) { // 0부터 11까지 반복\r\n                try {\r\n                    // 이미지 경로를 생성\r\n                    URL hpUrl = this.getClass().getResource(\"/images/hp_\" + i + \".png\");\r\n\r\n                    // URL이 null이 아닐 경우에만 이미지 읽기\r\n                    if (hpUrl != null) {\r\n                        hpImages[i] = ImageIO.read(hpUrl);\r\n                    } else {\r\n                        System.out.println(\"Image not found: /images/hp_\" + i + \".png\");\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace(); // IOException 처리\r\n                }\r\n            }\r\n\r\n            URL Buttonimg = this.getClass().getResource(\"/images/btn_buy.png\");\r\n            buttonImg = ImageIO.read(Buttonimg);\r\n\r\n            URL backgroundImgUrl = this.getClass().getResource(\"/images/background.png\");\r\n            backgroundImg = ImageIO.read(backgroundImgUrl);\r\n\r\n            URL bossImgUrl = this.getClass().getResource(\"/images/boss.png\");\r\n            bossImg = ImageIO.read(bossImgUrl);\r\n\r\n            URL grassImgUrl = this.getClass().getResource(\"/images/grass.png\");\r\n            grassImg = ImageIO.read(grassImgUrl);\r\n\r\n            URL sight_hunterURL = this.getClass().getResource(\"/images/sight_hunter.png\");\r\n            sightImg_hunter = ImageIO.read(sight_hunterURL);\r\n\r\n            URL duckImgUrl = this.getClass().getResource(\"/images/duck.png\");\r\n            duckImg = ImageIO.read(duckImgUrl);\r\n\r\n            URL sightImgUrl = this.getClass().getResource(\"/images/sight.png\");\r\n            sightImg = ImageIO.read(sightImgUrl);\r\n            sightImgMiddleWidth = sightImg.getWidth() / 2;\r\n            sightImgMiddleHeight = sightImg.getHeight() / 2;\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(Game.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n    }\r\n\r\n    private void selectPlayerDucks(int numberOfDucks) {\r\n        // 선택된 오리들이 이미 있으면 리턴\r\n        if (playerSelectedDucks != null) {\r\n            return;\r\n        }\r\n\r\n        // 오리들이 충분히 있을 때 N마리 오리를 무작위로 선택\r\n        if (ducks.size() >= numberOfDucks) {\r\n            playerSelectedDucks = new Duck[numberOfDucks]; // Player 선택된 오리 배열 초기화\r\n            Random random = new Random();\r\n\r\n            for (int i = 0; i < numberOfDucks; i++) {\r\n                Duck selectedDuck;\r\n                int index;\r\n\r\n                // 중복되지 않는 오리를 선택\r\n                do {\r\n                    index = random.nextInt(ducks.size());\r\n                    selectedDuck = ducks.get(index);\r\n                } while (Arrays.asList(playerSelectedDucks).contains(selectedDuck) ||\r\n                        (hunterSelectedDucks != null && Arrays.asList(hunterSelectedDucks).contains(selectedDuck))); // hunterSelectedDucks가 null일 경우 중복 방지 생략\r\n\r\n                playerSelectedDucks[i] = selectedDuck;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    // N마리 오리를 선택하는 메소드 (Hunter용)\r\n    private void selectHunterDucks(int numberOfDucks) {\r\n        if (ducks.size() >= numberOfDucks) {\r\n            hunterSelectedDucks = new Duck[numberOfDucks]; // Hunter 선택된 오리 배열 초기화\r\n            Random random = new Random();\r\n\r\n            for (int i = 0; i < numberOfDucks; i++) {\r\n                Duck selectedDuck;\r\n                int index;\r\n\r\n                // 중복되지 않는 오리를 선택\r\n                do {\r\n                    index = random.nextInt(ducks.size());\r\n                    selectedDuck = ducks.get(index);\r\n                } while (Arrays.asList(hunterSelectedDucks).contains(selectedDuck) || Arrays.asList(playerSelectedDucks).contains(selectedDuck)); // 중복 방지\r\n\r\n                hunterSelectedDucks[i] = selectedDuck;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Hunter가 자동으로 오리를 제거하는 메소드\r\n    private void startHunterAutoKill(int interval) {\r\n        hunterExecutor = Executors.newScheduledThreadPool(1); // 스레드 풀 생성\r\n        hunterExecutor.scheduleAtFixedRate(() -> {\r\n            if (hunterSelectedDucks == null || Arrays.stream(hunterSelectedDucks).allMatch(Objects::isNull)) {\r\n                // Hunter가 선택한 오리가 없으면 새롭게 선택\r\n                selectHunterDucks(1);\r\n            }\r\n            if (hunterSelectedDucks != null) {\r\n                for (Duck duck : hunterSelectedDucks) {\r\n                    if (duck != null && !Arrays.asList(playerSelectedDucks).contains(duck)) {\r\n                        // Hunter가 선택한 오리가 Player가 선택한 오리와 중복되지 않도록 확인\r\n                        ducks.remove(duck);\r\n                        killedDucks++;\r\n                        money += 10;\r\n                        score += duck.score;\r\n                        System.out.println(\"Hunter가 오리를 죽였습니다: \" + duck);\r\n                        break; // 한 마리씩 죽이고 나가도록\r\n\r\n                    }\r\n                }\r\n                updateHunterSelectedDucks();\r\n            }\r\n        }, 0, interval, TimeUnit.MILLISECONDS); // interval 시간마다 실행\r\n    }\r\n\r\n\r\n    // 게임이 끝나면 Hunter의 자동조준 타이머를 중지하는 코드\r\n    private void stopHunterAutoKill() {\r\n        if (hunterExecutor != null && !hunterExecutor.isShutdown()) {\r\n            hunterExecutor.shutdown(); // Hunter의 자동 조준 종료\r\n        }\r\n    }\r\n\r\n\r\n    private void updateAndReselectPlayerDucks(int numberOfDucks) {\r\n        // playerSelectedDucks가 null일 때만 새로 선택\r\n        playerSelectedDucks = null;\r\n        if (playerSelectedDucks == null) {\r\n            selectPlayerDucks(numberOfDucks);\r\n        }\r\n    }\r\n\r\n    // 오리들이 죽으면 Hunter 선택된 오리를 null로 설정\r\n    private void updateHunterSelectedDucks() {\r\n        Random random = new Random();\r\n\r\n        for (int i = 0; i < hunterSelectedDucks.length; i++) {\r\n            if (hunterSelectedDucks[i] == null || !ducks.contains(hunterSelectedDucks[i])) {\r\n                // 새로운 오리를 선택하여 중복되지 않게 추가\r\n                Duck selectedDuck;\r\n                int index;\r\n\r\n                do {\r\n                    index = random.nextInt(ducks.size());\r\n                    selectedDuck = ducks.get(index);\r\n                } while (Arrays.asList(hunterSelectedDucks).contains(selectedDuck) ||\r\n                        Arrays.asList(playerSelectedDucks).contains(selectedDuck)); // 중복 방지\r\n\r\n                hunterSelectedDucks[i] = selectedDuck;\r\n            }\r\n        }\r\n    }\r\n\r\n    // 더블배럴샷건 모드에서 Player 선택된 오리들에게 sightImg를 그리기\r\n    private void drawSightOnPlayerSelectedDucks(Graphics2D g2d) {\r\n        if (playerSelectedDucks != null) {\r\n            for (Duck duck : playerSelectedDucks) {\r\n                if (duck != null) {\r\n                    g2d.drawImage(sightImg, duck.x, duck.y, null);\r\n                }\r\n            }\r\n        }else{\r\n            return;\r\n        }\r\n    }\r\n\r\n    // 더블배럴샷건 모드에서 Hunter 선택된 오리들에게 sightImg를 그리기\r\n    private void drawSightOnHunterSelectedDucks(Graphics2D g2d) {\r\n        if (hunterSelectedDucks != null) {\r\n            for (Duck duck : hunterSelectedDucks) {\r\n                if (duck != null) {\r\n                    g2d.drawImage(sightImg_hunter, duck.x, duck.y,28,28,null);\r\n                }else{\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restart game - reset some variables.\r\n     */\r\n    public void RestartGame() {\r\n        // Removes all of the ducks from this list.\r\n        ducks.clear();\r\n\r\n        // We set last duckt time to zero.\r\n        Duck.lastDuckTime = 0;\r\n\r\n        runawayDucks = 0;\r\n        killedDucks = 0;\r\n        score = 0;\r\n        shoots = 0;\r\n\r\n        lastTimeShoot = 0;\r\n    }\r\n\r\n    public void Pause() {\r\n        ducks.clear();\r\n        isPause = true;\r\n        System.out.println(\"buttonbuyadd\");\r\n        Framework.gameState = Framework.GameState.Pause;\r\n    }\r\n\r\n\r\n    public void NextRound() {\r\n        isPause = false;\r\n        Framework.gameState = Framework.GameState.PLAYING;\r\n        Duck.lastDuckTime = 0; // 오리 타이머 초기화\r\n        killedDucks = 0; // 죽인 오리 수 초기화\r\n        runawayDucks = 0; // 도망간 오리 수 초기화\r\n        Round += 1;\r\n        isBossAlive = false;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Update game logic.\r\n     *\r\n     * @param gameTime      gameTime of the game.\r\n     * @param mousePosition current mouse position.\r\n     */\r\n    public void UpdateGame(long gameTime, Point mousePosition) {\r\n        if(isBossAlive){\r\n            for (int i = 0; i < boss.size(); i++) {\r\n                boss.get(i).update(); // 보스 위치 업데이트\r\n            }\r\n        }\r\n\r\n        if(Hunter1&& hunterTrigger){\r\n            startHunterAutoKill(2500);\r\n            hunterTrigger = false;\r\n        }else if(!Hunter1){\r\n            stopHunterAutoKill();\r\n        }else if(!hunterTrigger){\r\n\r\n        }\r\n        if(!isPause) {\r\n            // Creates a new duck, if it's the time, and add it to the array list.\r\n            if (System.nanoTime() - Duck.lastDuckTime >= Duck.timeBetweenDucks) {\r\n\r\n                if (isReloading) {\r\n                    if (System.nanoTime() - reloadStartTime >= reloadDuration) {\r\n                        ammo = maxAmmo;   // 탄약을 최대치로 채움\r\n                        isReloading = false; // 장전 상태 해제\r\n                    }\r\n                }\r\n                if(ammo<=0 && !isReloading){\r\n                    Reload();\r\n                }\r\n\r\n                if (framework.getGun().equals(\"더블배럴샷건\")) {\r\n                    selectPlayerDucks(1);\r\n                    // 선택된 오리들이 죽었는지 확인하고, 죽으면 다시 선택\r\n                }else if(framework.getGun().equals(\"기본권총\")){\r\n\r\n                }\r\n                // Here we create new duck and add it to the array list.\r\n                ducks.add(new Duck(Duck.duckLines[Duck.nextDuckLines][0] + random.nextInt(200), Duck.duckLines[Duck.nextDuckLines][1], Duck.duckLines[Duck.nextDuckLines][2], Duck.duckLines[Duck.nextDuckLines][3], duckImg));\r\n                // Here we increase nextDuckLines so that next duck will be created in next line.\r\n                Duck.nextDuckLines++;\r\n                if (Duck.nextDuckLines >= Duck.duckLines.length)\r\n                    Duck.nextDuckLines = 0;\r\n\r\n                if (killedDucks >= 20 && !isBossAlive) {\r\n                    // 보스 생성\r\n                    boss.add(new boss1(1300, 500,0.125,3000,3000,bossImg));\r\n                    isBossAlive = true; // 보스가 등장했음을 표시\r\n                    System.out.println(\"boss activity\");\r\n                    ducks.clear();\r\n                }\r\n                Duck.lastDuckTime = System.nanoTime();\r\n            }\r\n\r\n            if(!isBossAlive) {\r\n                // Update all of the ducks.\r\n                for (int i = 0; i < ducks.size(); i++) {\r\n                    // Move the duck.\r\n                    ducks.get(i).Update();\r\n                    server.uploadDuck(ducks.get(i));\r\n                    // Checks if the duck leaves the screen and remove it if it does.\r\n                    if (ducks.get(i).x < 0 - duckImg.getWidth()) {\r\n                        ducks.remove(i);\r\n                        runawayDucks++;\r\n                    }\r\n                }\r\n                // Does player shoots?\r\n                if (kr.jbnu.se.std.Canvas.mouseButtonState(MouseEvent.BUTTON1) && !isReloading) {\r\n                    if (System.nanoTime() - lastTimeShoot >= timeBetweenShots) {\r\n                        shoots++;\r\n                        ammo--;\r\n                        if (playerSelectedDucks != null) {\r\n                            for (int i = 0; i < playerSelectedDucks.length; i++) {\r\n                                if (playerSelectedDucks[i] != null) {\r\n                                    killedDucks++; // 죽인 오리 수 증가\r\n                                    money += 10; // 돈 증가\r\n                                    score += playerSelectedDucks[i].score; // 점수 증가\r\n\r\n                                    // 오리 리스트에서 제거\r\n                                    ducks.remove(playerSelectedDucks[i]);\r\n\r\n                                    // 선택된 오리를 null로 설정하여 초기화\r\n                                    playerSelectedDucks[i] = null;\r\n                                    updateAndReselectPlayerDucks(1);\r\n                                }\r\n                            }\r\n                        }\r\n                        // We go over all the ducks and we look if any of them was shoot.\r\n                        for (int i = 0; i < ducks.size(); i++) {\r\n                            // We check, if the mouse was over ducks head or body, when player has shot.\r\n                            if (new Rectangle(ducks.get(i).x + 18, ducks.get(i).y, 27, 30).contains(mousePosition) ||\r\n                                    new Rectangle(ducks.get(i).x + 30, ducks.get(i).y + 30, 88, 25).contains(mousePosition)) {\r\n                                killedDucks++;\r\n                                money += 10;\r\n                                score += ducks.get(i).score;\r\n\r\n                                // Remove the duck from the array list.\r\n                                ducks.remove(i);\r\n\r\n                                // We found the duck that player shoot so we can leave the for loop.\r\n                                break;\r\n                            }\r\n                        }\r\n                        // We go over all the bosses and we look if any of them was shoot.\r\n                        // We go over all the bosses and we look if any of them was shoot.\r\n\r\n\r\n                        lastTimeShoot = System.nanoTime();\r\n                    }\r\n                }\r\n            }else {\r\n                if (kr.jbnu.se.std.Canvas.mouseButtonState(MouseEvent.BUTTON1) && !isReloading) {\r\n                    if (System.nanoTime() - lastTimeShoot >= timeBetweenShots) {\r\n                        ammo--;\r\n                        if (isBossAlive) {\r\n                            for (int i = 0; i < boss.size(); i++) {\r\n                                // Define the boss hitbox (for exampl, a larger area for the boss).\r\n                                if (new Rectangle(boss.get(i).x, boss.get(i).y, 100, 100).contains(mousePosition)) {\r\n                                    // Reduce boss health\r\n                                    boss.get(i).health -= 20; // Reduce boss health by 20 on each hit.\r\n                                    System.out.println(\"attack boss\");\r\n                                    System.out.println(boss.get(i).health);\r\n                                    // If the boss is dead, update score, money, etc.\r\n                                    if (boss.get(i).health <= 0) {\r\n                                        money += 100; // Bosses give more money\r\n                                        score += boss.get(i).score; // Boss-specific score\r\n                                        boss.remove(i);\r\n                                        Pause();\r\n                                        // Remove the boss from the array list.\r\n                                    }\r\n                                    break;\r\n                                    // Since a boss was hit, we can leave the loop.\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    lastTimeShoot = System.nanoTime();\r\n                }\r\n            }\r\n\r\n            // When 200 ducks runaway, the game ends.\r\n            if (runawayDucks >= 10)\r\n                Framework.gameState = Framework.GameState.GAMEOVER;\r\n            if (Framework.gameState == Framework.GameState.GAMEOVER && !leaderboardSaved) {\r\n                framework.saveScore(score);\r\n                leaderboardSaved = true;  // 리더보드 저장 완료\r\n            }\r\n        }\r\n        if(isPause) {\r\n            System.out.println(\"isPause\");\r\n            buttonbuy.add(new Buttonbuy(framework.getWidth()/2 - 300, framework.getHeight()/2+50, buttonImg));\r\n            for (int i = 0; i < buttonbuy.size(); i++) {\r\n                if (Canvas.mouseButtonState(MouseEvent.BUTTON1) && money > 200) {\r\n                    if (new Rectangle(buttonbuy.get(i).x, buttonbuy.get(i).y, 367, 257).contains(mousePosition)) {\r\n                        System.out.println(\"buybutton\");\r\n                        System.out.println(mousePosition);\r\n                        System.out.println(buttonbuy.get(i).x + \" \" + buttonbuy.get(i).y);\r\n                        Hunters.add(new Hunter1(220, 110, 0, 100, duckImg));\r\n                        Hunter1 = true;\r\n                        money -= 200;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw the game to the screen.\r\n     *\r\n     * @param g2d Graphics2D\r\n     * @param mousePosition current mouse position.\r\n     */\r\n    public void Draw(Graphics2D g2d, Point mousePosition)\r\n    {\r\n        g2d.drawImage(backgroundImg, 0, 0, Framework.frameWidth, Framework.frameHeight, null);\r\n\r\n        // Here we draw all the ducks.\r\n        for(int i = 0; i < ducks.size(); i++)\r\n        {\r\n            ducks.get(i).Draw(g2d);\r\n        }\r\n        if(Hunter1){\r\n            g2d.drawImage(bossImg,Hunters.get(0).x,Hunters.get(0).y,null);\r\n            drawSightOnHunterSelectedDucks(g2d);\r\n\r\n        }\r\n\r\n        if(isPause){\r\n            int buyWidth = buttonImg.getWidth(null) / 2; // 너비 50%\r\n            int buyHeight = buttonImg.getHeight(null) / 2; // 높이 50%\r\n            for(int i = 0; i < buttonbuy.size(); i++) {\r\n                g2d.drawImage(buttonImg, buttonbuy.get(i).x, buttonbuy.get(i).y,buyWidth,buyHeight,null);\r\n            }\r\n        }\r\n        // 보스 그리기\r\n        if (!boss.isEmpty()) {\r\n            for (int i = 0; i < boss.size(); i++) {\r\n                // 보스 이미지 그리기\r\n                g2d.drawImage(bossImg, boss.get(i).x, boss.get(i).y - 20, null);\r\n\r\n                // 보스의 체력 상태를 기반으로 HP 이미지를 선택\r\n                int currentHealth = boss.get(i).health;\r\n                int maxHealth = boss.get(i).maxHealth; // 보스의 최대 체력\r\n\r\n                // 체력에 따른 HP 이미지를 표시\r\n                int hpIndex = (int) ((currentHealth / (double) maxHealth) * 11); // 0에서 11까지의 인덱스를 계산\r\n                hpIndex = Math.max(0, Math.min(11, hpIndex)); // 범위를 0 ~ 11로 제한\r\n                // HP 바 크기 조정 (예: 50% 크기)\r\n                int hpBarWidth = hpImages[hpIndex].getWidth(null) / 8; // 너비 50%\r\n                int hpBarHeight = hpImages[hpIndex].getHeight(null) / 8; // 높이 50%\r\n\r\n                // HP 바 그리기 (크기 조정 후)\r\n                g2d.drawImage(hpImages[hpIndex], boss.get(i).x - 20, boss.get(i).y - 60, hpBarWidth, hpBarHeight, null);\r\n            }\r\n        }\r\n\r\n        if(isReloading){\r\n            g2d.drawString(\"Reloading\", Framework.frameWidth/2, Framework.frameHeight/2);\r\n        }\r\n\r\n        g2d.drawImage(sightImg, mousePosition.x - sightImgMiddleWidth, mousePosition.y - sightImgMiddleHeight, null);\r\n        // 더블배럴샷건일 때 랜덤 오리 2마리 지정\r\n        if (framework.getGun().equals(\"더블배럴샷건\")) {\r\n            drawSightOnPlayerSelectedDucks(g2d);\r\n            reloadDuration = 2500000000L;\r\n        }\r\n        if(framework.getGun().equals(\"AK-47\")){\r\n            maxAmmo = 30;\r\n            reloadDuration = 3000000000L;\r\n            timeBetweenShots = 100_000_000L;\r\n        }\r\n\r\n        g2d.setFont(font);\r\n        g2d.setColor(Color.darkGray);\r\n\r\n        g2d.drawString(\"Ammo: \" + ammo + \"/\" + maxAmmo, 10, 50);\r\n        g2d.drawString(\"RUNAWAY: \" + runawayDucks, 10, 21);\r\n        g2d.drawString(\"KILLS: \" + killedDucks, 160, 21);\r\n        g2d.drawString(\"SHOOTS: \" + shoots, 299, 21);\r\n        g2d.drawString(\"SCORE: \" + score, 440, 21);\r\n        g2d.drawString(\"Round: \" + Round, 570, 21);\r\n        g2d.drawString(\"Money: \" + money, 700, 21);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Draw the game over screen.\r\n     *\r\n     * @param g2d Graphics2D\r\n     * @param mousePosition Current mouse position.\r\n     */\r\n    public void DrawGameOver(Graphics2D g2d, Point mousePosition)\r\n    {\r\n        Draw(g2d, mousePosition);\r\n\r\n        // The first text is used for shade.\r\n        g2d.setColor(Color.black);\r\n        g2d.drawString(\"kr.jbnu.se.std.Game Over\", Framework.frameWidth / 2 - 39, (int)(Framework.frameHeight * 0.65) + 1);\r\n        g2d.drawString(\"Press space or enter to restart.\", Framework.frameWidth / 2 - 149, (int)(Framework.frameHeight * 0.70) + 1);\r\n        g2d.setColor(Color.red);\r\n        g2d.drawString(\"kr.jbnu.se.std.Game Over\", Framework.frameWidth / 2 - 40, (int)(Framework.frameHeight * 0.65));\r\n        g2d.drawString(\"Press space or enter to restart.\", Framework.frameWidth / 2 - 150, (int)(Framework.frameHeight * 0.70));\r\n    }\r\n\r\n    public int getScore(){\r\n        return score;\r\n    }\r\n\r\n    public void setgun(String gun){\r\n        this.gun = gun;\r\n    }\r\n\r\n    private void Reload() {\r\n        isReloading = true;\r\n        reloadStartTime = System.nanoTime();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/kr/jbnu/se/std/MultiPlayer/MultiGame.java b/src/main/java/kr/jbnu/se/std/MultiPlayer/MultiGame.java
--- a/src/main/java/kr/jbnu/se/std/MultiPlayer/MultiGame.java	(revision 137fa387678d3515712c7f9341873492602cb66b)
+++ b/src/main/java/kr/jbnu/se/std/MultiPlayer/MultiGame.java	(date 1733065724479)
@@ -386,7 +386,7 @@
         ducks.clear();
         isPause = true;
         System.out.println("buttonbuyadd");
-        Framework.gameState = Framework.GameState.Pause;
+        Framework.gameState = Framework.GameState.PAUSE;
     }
 
 
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ExternalStorageConfigurationManager\" enabled=\"true\" />\r\n  <component name=\"MavenProjectsManager\">\r\n    <option name=\"originalFiles\">\r\n      <list>\r\n        <option value=\"$PROJECT_DIR$/pom.xml\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_1_8\" default=\"true\" project-jdk-name=\"1.8\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 137fa387678d3515712c7f9341873492602cb66b)
+++ b/.idea/misc.xml	(date 1733065690565)
@@ -1,5 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="EntryPointsManager">
+    <entry_points version="2.0">
+      <entry_point TYPE="field" FQNAME="kr.jbnu.se.std.Game endingStartTime" />
+    </entry_points>
+  </component>
   <component name="ExternalStorageConfigurationManager" enabled="true" />
   <component name="MavenProjectsManager">
     <option name="originalFiles">
